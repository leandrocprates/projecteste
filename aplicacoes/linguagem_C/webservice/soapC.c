/* soapC.c
   Generated by gSOAP 2.8.2 from mbatch_server.h
   Copyright(C) 2000-2011, Robert van Engelen, Genivia Inc. All Rights Reserved.
   The generated code is released under one of the following licenses:
   GPL OR Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.8.2 2011-06-20 21:40:23 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header))))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_ns1__invalidRegisterResponse:
		return soap_in_ns1__invalidRegisterResponse(soap, NULL, NULL, "ns1:invalidRegisterResponse");
	case SOAP_TYPE_ns1__invalidRegister:
		return soap_in_ns1__invalidRegister(soap, NULL, NULL, "ns1:invalidRegister");
	case SOAP_TYPE_ns1__sendResponse:
		return soap_in_ns1__sendResponse(soap, NULL, NULL, "ns1:sendResponse");
	case SOAP_TYPE_ns3__stringArray:
		return soap_in_ns3__stringArray(soap, NULL, NULL, "ns3:stringArray");
	case SOAP_TYPE_ns1__send:
		return soap_in_ns1__send(soap, NULL, NULL, "ns1:send");
	case SOAP_TYPE_ns1__checkStatusResponse:
		return soap_in_ns1__checkStatusResponse(soap, NULL, NULL, "ns1:checkStatusResponse");
	case SOAP_TYPE_ns1__checkStatus:
		return soap_in_ns1__checkStatus(soap, NULL, NULL, "ns1:checkStatus");
	case SOAP_TYPE_ns1__validRegisterResponse:
		return soap_in_ns1__validRegisterResponse(soap, NULL, NULL, "ns1:validRegisterResponse");
	case SOAP_TYPE_ns1__validRegister:
		return soap_in_ns1__validRegister(soap, NULL, NULL, "ns1:validRegister");
	case SOAP_TYPE_ns1__sentMessageResponse:
		return soap_in_ns1__sentMessageResponse(soap, NULL, NULL, "ns1:sentMessageResponse");
	case SOAP_TYPE_ns1__sentMessage:
		return soap_in_ns1__sentMessage(soap, NULL, NULL, "ns1:sentMessage");
	case SOAP_TYPE_ns1__checkStatusMessageResponse:
		return soap_in_ns1__checkStatusMessageResponse(soap, NULL, NULL, "ns1:checkStatusMessageResponse");
	case SOAP_TYPE_ns1__checkStatusMessage:
		return soap_in_ns1__checkStatusMessage(soap, NULL, NULL, "ns1:checkStatusMessage");
	case SOAP_TYPE_ns1__BatchException:
		return soap_in_ns1__BatchException(soap, NULL, NULL, "ns1:BatchException");
	case SOAP_TYPE_ns1__totalRegisterResponse:
		return soap_in_ns1__totalRegisterResponse(soap, NULL, NULL, "ns1:totalRegisterResponse");
	case SOAP_TYPE_ns1__totalRegister:
		return soap_in_ns1__totalRegister(soap, NULL, NULL, "ns1:totalRegister");
	case SOAP_TYPE_PointerTons1__sentMessageResponse:
		return soap_in_PointerTons1__sentMessageResponse(soap, NULL, NULL, "ns1:sentMessageResponse");
	case SOAP_TYPE_PointerTons1__sentMessage:
		return soap_in_PointerTons1__sentMessage(soap, NULL, NULL, "ns1:sentMessage");
	case SOAP_TYPE_PointerTons1__totalRegisterResponse:
		return soap_in_PointerTons1__totalRegisterResponse(soap, NULL, NULL, "ns1:totalRegisterResponse");
	case SOAP_TYPE_PointerTons1__totalRegister:
		return soap_in_PointerTons1__totalRegister(soap, NULL, NULL, "ns1:totalRegister");
	case SOAP_TYPE_PointerTons1__invalidRegisterResponse:
		return soap_in_PointerTons1__invalidRegisterResponse(soap, NULL, NULL, "ns1:invalidRegisterResponse");
	case SOAP_TYPE_PointerTons1__invalidRegister:
		return soap_in_PointerTons1__invalidRegister(soap, NULL, NULL, "ns1:invalidRegister");
	case SOAP_TYPE_PointerTons1__validRegisterResponse:
		return soap_in_PointerTons1__validRegisterResponse(soap, NULL, NULL, "ns1:validRegisterResponse");
	case SOAP_TYPE_PointerTons1__validRegister:
		return soap_in_PointerTons1__validRegister(soap, NULL, NULL, "ns1:validRegister");
	case SOAP_TYPE_PointerTons1__checkStatusMessageResponse:
		return soap_in_PointerTons1__checkStatusMessageResponse(soap, NULL, NULL, "ns1:checkStatusMessageResponse");
	case SOAP_TYPE_PointerTons1__checkStatusMessage:
		return soap_in_PointerTons1__checkStatusMessage(soap, NULL, NULL, "ns1:checkStatusMessage");
	case SOAP_TYPE_PointerTons1__checkStatusResponse:
		return soap_in_PointerTons1__checkStatusResponse(soap, NULL, NULL, "ns1:checkStatusResponse");
	case SOAP_TYPE_PointerTons1__checkStatus:
		return soap_in_PointerTons1__checkStatus(soap, NULL, NULL, "ns1:checkStatus");
	case SOAP_TYPE_PointerTons1__sendResponse:
		return soap_in_PointerTons1__sendResponse(soap, NULL, NULL, "ns1:sendResponse");
	case SOAP_TYPE_PointerTons1__send:
		return soap_in_PointerTons1__send(soap, NULL, NULL, "ns1:send");
	case SOAP_TYPE_PointerTons1__BatchException:
		return soap_in_PointerTons1__BatchException(soap, NULL, NULL, "ns1:BatchException");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons3__stringArray:
		return soap_in_PointerTons3__stringArray(soap, NULL, NULL, "ns3:stringArray");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:invalidRegisterResponse"))
		{	*type = SOAP_TYPE_ns1__invalidRegisterResponse;
			return soap_in_ns1__invalidRegisterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:invalidRegister"))
		{	*type = SOAP_TYPE_ns1__invalidRegister;
			return soap_in_ns1__invalidRegister(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sendResponse"))
		{	*type = SOAP_TYPE_ns1__sendResponse;
			return soap_in_ns1__sendResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:stringArray"))
		{	*type = SOAP_TYPE_ns3__stringArray;
			return soap_in_ns3__stringArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:send"))
		{	*type = SOAP_TYPE_ns1__send;
			return soap_in_ns1__send(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkStatusResponse"))
		{	*type = SOAP_TYPE_ns1__checkStatusResponse;
			return soap_in_ns1__checkStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkStatus"))
		{	*type = SOAP_TYPE_ns1__checkStatus;
			return soap_in_ns1__checkStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:validRegisterResponse"))
		{	*type = SOAP_TYPE_ns1__validRegisterResponse;
			return soap_in_ns1__validRegisterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:validRegister"))
		{	*type = SOAP_TYPE_ns1__validRegister;
			return soap_in_ns1__validRegister(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sentMessageResponse"))
		{	*type = SOAP_TYPE_ns1__sentMessageResponse;
			return soap_in_ns1__sentMessageResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sentMessage"))
		{	*type = SOAP_TYPE_ns1__sentMessage;
			return soap_in_ns1__sentMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkStatusMessageResponse"))
		{	*type = SOAP_TYPE_ns1__checkStatusMessageResponse;
			return soap_in_ns1__checkStatusMessageResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkStatusMessage"))
		{	*type = SOAP_TYPE_ns1__checkStatusMessage;
			return soap_in_ns1__checkStatusMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BatchException"))
		{	*type = SOAP_TYPE_ns1__BatchException;
			return soap_in_ns1__BatchException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:totalRegisterResponse"))
		{	*type = SOAP_TYPE_ns1__totalRegisterResponse;
			return soap_in_ns1__totalRegisterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:totalRegister"))
		{	*type = SOAP_TYPE_ns1__totalRegister;
			return soap_in_ns1__totalRegister(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_ns1__invalidRegisterResponse:
		return soap_out_ns1__invalidRegisterResponse(soap, tag, id, (const struct ns1__invalidRegisterResponse *)ptr, "ns1:invalidRegisterResponse");
	case SOAP_TYPE_ns1__invalidRegister:
		return soap_out_ns1__invalidRegister(soap, tag, id, (const struct ns1__invalidRegister *)ptr, "ns1:invalidRegister");
	case SOAP_TYPE_ns1__sendResponse:
		return soap_out_ns1__sendResponse(soap, tag, id, (const struct ns1__sendResponse *)ptr, "ns1:sendResponse");
	case SOAP_TYPE_ns3__stringArray:
		return soap_out_ns3__stringArray(soap, tag, id, (const struct ns3__stringArray *)ptr, "ns3:stringArray");
	case SOAP_TYPE_ns1__send:
		return soap_out_ns1__send(soap, tag, id, (const struct ns1__send *)ptr, "ns1:send");
	case SOAP_TYPE_ns1__checkStatusResponse:
		return soap_out_ns1__checkStatusResponse(soap, tag, id, (const struct ns1__checkStatusResponse *)ptr, "ns1:checkStatusResponse");
	case SOAP_TYPE_ns1__checkStatus:
		return soap_out_ns1__checkStatus(soap, tag, id, (const struct ns1__checkStatus *)ptr, "ns1:checkStatus");
	case SOAP_TYPE_ns1__validRegisterResponse:
		return soap_out_ns1__validRegisterResponse(soap, tag, id, (const struct ns1__validRegisterResponse *)ptr, "ns1:validRegisterResponse");
	case SOAP_TYPE_ns1__validRegister:
		return soap_out_ns1__validRegister(soap, tag, id, (const struct ns1__validRegister *)ptr, "ns1:validRegister");
	case SOAP_TYPE_ns1__sentMessageResponse:
		return soap_out_ns1__sentMessageResponse(soap, tag, id, (const struct ns1__sentMessageResponse *)ptr, "ns1:sentMessageResponse");
	case SOAP_TYPE_ns1__sentMessage:
		return soap_out_ns1__sentMessage(soap, tag, id, (const struct ns1__sentMessage *)ptr, "ns1:sentMessage");
	case SOAP_TYPE_ns1__checkStatusMessageResponse:
		return soap_out_ns1__checkStatusMessageResponse(soap, tag, id, (const struct ns1__checkStatusMessageResponse *)ptr, "ns1:checkStatusMessageResponse");
	case SOAP_TYPE_ns1__checkStatusMessage:
		return soap_out_ns1__checkStatusMessage(soap, tag, id, (const struct ns1__checkStatusMessage *)ptr, "ns1:checkStatusMessage");
	case SOAP_TYPE_ns1__BatchException:
		return soap_out_ns1__BatchException(soap, tag, id, (const struct ns1__BatchException *)ptr, "ns1:BatchException");
	case SOAP_TYPE_ns1__totalRegisterResponse:
		return soap_out_ns1__totalRegisterResponse(soap, tag, id, (const struct ns1__totalRegisterResponse *)ptr, "ns1:totalRegisterResponse");
	case SOAP_TYPE_ns1__totalRegister:
		return soap_out_ns1__totalRegister(soap, tag, id, (const struct ns1__totalRegister *)ptr, "ns1:totalRegister");
	case SOAP_TYPE_PointerTons1__sentMessageResponse:
		return soap_out_PointerTons1__sentMessageResponse(soap, tag, id, (struct ns1__sentMessageResponse *const*)ptr, "ns1:sentMessageResponse");
	case SOAP_TYPE_PointerTons1__sentMessage:
		return soap_out_PointerTons1__sentMessage(soap, tag, id, (struct ns1__sentMessage *const*)ptr, "ns1:sentMessage");
	case SOAP_TYPE_PointerTons1__totalRegisterResponse:
		return soap_out_PointerTons1__totalRegisterResponse(soap, tag, id, (struct ns1__totalRegisterResponse *const*)ptr, "ns1:totalRegisterResponse");
	case SOAP_TYPE_PointerTons1__totalRegister:
		return soap_out_PointerTons1__totalRegister(soap, tag, id, (struct ns1__totalRegister *const*)ptr, "ns1:totalRegister");
	case SOAP_TYPE_PointerTons1__invalidRegisterResponse:
		return soap_out_PointerTons1__invalidRegisterResponse(soap, tag, id, (struct ns1__invalidRegisterResponse *const*)ptr, "ns1:invalidRegisterResponse");
	case SOAP_TYPE_PointerTons1__invalidRegister:
		return soap_out_PointerTons1__invalidRegister(soap, tag, id, (struct ns1__invalidRegister *const*)ptr, "ns1:invalidRegister");
	case SOAP_TYPE_PointerTons1__validRegisterResponse:
		return soap_out_PointerTons1__validRegisterResponse(soap, tag, id, (struct ns1__validRegisterResponse *const*)ptr, "ns1:validRegisterResponse");
	case SOAP_TYPE_PointerTons1__validRegister:
		return soap_out_PointerTons1__validRegister(soap, tag, id, (struct ns1__validRegister *const*)ptr, "ns1:validRegister");
	case SOAP_TYPE_PointerTons1__checkStatusMessageResponse:
		return soap_out_PointerTons1__checkStatusMessageResponse(soap, tag, id, (struct ns1__checkStatusMessageResponse *const*)ptr, "ns1:checkStatusMessageResponse");
	case SOAP_TYPE_PointerTons1__checkStatusMessage:
		return soap_out_PointerTons1__checkStatusMessage(soap, tag, id, (struct ns1__checkStatusMessage *const*)ptr, "ns1:checkStatusMessage");
	case SOAP_TYPE_PointerTons1__checkStatusResponse:
		return soap_out_PointerTons1__checkStatusResponse(soap, tag, id, (struct ns1__checkStatusResponse *const*)ptr, "ns1:checkStatusResponse");
	case SOAP_TYPE_PointerTons1__checkStatus:
		return soap_out_PointerTons1__checkStatus(soap, tag, id, (struct ns1__checkStatus *const*)ptr, "ns1:checkStatus");
	case SOAP_TYPE_PointerTons1__sendResponse:
		return soap_out_PointerTons1__sendResponse(soap, tag, id, (struct ns1__sendResponse *const*)ptr, "ns1:sendResponse");
	case SOAP_TYPE_PointerTons1__send:
		return soap_out_PointerTons1__send(soap, tag, id, (struct ns1__send *const*)ptr, "ns1:send");
	case SOAP_TYPE_PointerTons1__BatchException:
		return soap_out_PointerTons1__BatchException(soap, tag, id, (struct ns1__BatchException *const*)ptr, "ns1:BatchException");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons3__stringArray:
		return soap_out_PointerTons3__stringArray(soap, tag, id, (struct ns3__stringArray *const*)ptr, "ns3:stringArray");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE___ns1__sentMessage:
		soap_serialize___ns1__sentMessage(soap, (const struct __ns1__sentMessage *)ptr);
		break;
	case SOAP_TYPE___ns1__totalRegister:
		soap_serialize___ns1__totalRegister(soap, (const struct __ns1__totalRegister *)ptr);
		break;
	case SOAP_TYPE___ns1__invalidRegister:
		soap_serialize___ns1__invalidRegister(soap, (const struct __ns1__invalidRegister *)ptr);
		break;
	case SOAP_TYPE___ns1__validRegister:
		soap_serialize___ns1__validRegister(soap, (const struct __ns1__validRegister *)ptr);
		break;
	case SOAP_TYPE___ns1__checkStatusMessage:
		soap_serialize___ns1__checkStatusMessage(soap, (const struct __ns1__checkStatusMessage *)ptr);
		break;
	case SOAP_TYPE___ns1__checkStatus:
		soap_serialize___ns1__checkStatus(soap, (const struct __ns1__checkStatus *)ptr);
		break;
	case SOAP_TYPE___ns1__send:
		soap_serialize___ns1__send(soap, (const struct __ns1__send *)ptr);
		break;
	case SOAP_TYPE_ns1__invalidRegisterResponse:
		soap_serialize_ns1__invalidRegisterResponse(soap, (const struct ns1__invalidRegisterResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__invalidRegister:
		soap_serialize_ns1__invalidRegister(soap, (const struct ns1__invalidRegister *)ptr);
		break;
	case SOAP_TYPE_ns1__sendResponse:
		soap_serialize_ns1__sendResponse(soap, (const struct ns1__sendResponse *)ptr);
		break;
	case SOAP_TYPE_ns3__stringArray:
		soap_serialize_ns3__stringArray(soap, (const struct ns3__stringArray *)ptr);
		break;
	case SOAP_TYPE_ns1__send:
		soap_serialize_ns1__send(soap, (const struct ns1__send *)ptr);
		break;
	case SOAP_TYPE_ns1__checkStatusResponse:
		soap_serialize_ns1__checkStatusResponse(soap, (const struct ns1__checkStatusResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__checkStatus:
		soap_serialize_ns1__checkStatus(soap, (const struct ns1__checkStatus *)ptr);
		break;
	case SOAP_TYPE_ns1__validRegisterResponse:
		soap_serialize_ns1__validRegisterResponse(soap, (const struct ns1__validRegisterResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__validRegister:
		soap_serialize_ns1__validRegister(soap, (const struct ns1__validRegister *)ptr);
		break;
	case SOAP_TYPE_ns1__sentMessageResponse:
		soap_serialize_ns1__sentMessageResponse(soap, (const struct ns1__sentMessageResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__sentMessage:
		soap_serialize_ns1__sentMessage(soap, (const struct ns1__sentMessage *)ptr);
		break;
	case SOAP_TYPE_ns1__checkStatusMessageResponse:
		soap_serialize_ns1__checkStatusMessageResponse(soap, (const struct ns1__checkStatusMessageResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__checkStatusMessage:
		soap_serialize_ns1__checkStatusMessage(soap, (const struct ns1__checkStatusMessage *)ptr);
		break;
	case SOAP_TYPE_ns1__BatchException:
		soap_serialize_ns1__BatchException(soap, (const struct ns1__BatchException *)ptr);
		break;
	case SOAP_TYPE_ns1__totalRegisterResponse:
		soap_serialize_ns1__totalRegisterResponse(soap, (const struct ns1__totalRegisterResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__totalRegister:
		soap_serialize_ns1__totalRegister(soap, (const struct ns1__totalRegister *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__sentMessageResponse:
		soap_serialize_PointerTons1__sentMessageResponse(soap, (struct ns1__sentMessageResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__sentMessage:
		soap_serialize_PointerTons1__sentMessage(soap, (struct ns1__sentMessage *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__totalRegisterResponse:
		soap_serialize_PointerTons1__totalRegisterResponse(soap, (struct ns1__totalRegisterResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__totalRegister:
		soap_serialize_PointerTons1__totalRegister(soap, (struct ns1__totalRegister *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__invalidRegisterResponse:
		soap_serialize_PointerTons1__invalidRegisterResponse(soap, (struct ns1__invalidRegisterResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__invalidRegister:
		soap_serialize_PointerTons1__invalidRegister(soap, (struct ns1__invalidRegister *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__validRegisterResponse:
		soap_serialize_PointerTons1__validRegisterResponse(soap, (struct ns1__validRegisterResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__validRegister:
		soap_serialize_PointerTons1__validRegister(soap, (struct ns1__validRegister *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__checkStatusMessageResponse:
		soap_serialize_PointerTons1__checkStatusMessageResponse(soap, (struct ns1__checkStatusMessageResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__checkStatusMessage:
		soap_serialize_PointerTons1__checkStatusMessage(soap, (struct ns1__checkStatusMessage *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__checkStatusResponse:
		soap_serialize_PointerTons1__checkStatusResponse(soap, (struct ns1__checkStatusResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__checkStatus:
		soap_serialize_PointerTons1__checkStatus(soap, (struct ns1__checkStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__sendResponse:
		soap_serialize_PointerTons1__sendResponse(soap, (struct ns1__sendResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__send:
		soap_serialize_PointerTons1__send(soap, (struct ns1__send *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BatchException:
		soap_serialize_PointerTons1__BatchException(soap, (struct ns1__BatchException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__stringArray:
		soap_serialize_PointerTons3__stringArray(soap, (struct ns3__stringArray *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__sentMessage(struct soap *soap, struct __ns1__sentMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__sentMessage = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__sentMessage(struct soap *soap, const struct __ns1__sentMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__sentMessage(soap, &a->ns1__sentMessage);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__sentMessage(struct soap *soap, const char *tag, int id, const struct __ns1__sentMessage *a, const char *type)
{
	if (soap_out_PointerTons1__sentMessage(soap, "ns1:sentMessage", -1, &a->ns1__sentMessage, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sentMessage * SOAP_FMAC4 soap_in___ns1__sentMessage(struct soap *soap, const char *tag, struct __ns1__sentMessage *a, const char *type)
{
	size_t soap_flag_ns1__sentMessage = 1;
	short soap_flag;
	a = (struct __ns1__sentMessage *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__sentMessage, sizeof(struct __ns1__sentMessage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__sentMessage(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__sentMessage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sentMessage(soap, "ns1:sentMessage", &a->ns1__sentMessage, "ns1:sentMessage"))
				{	soap_flag_ns1__sentMessage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__sentMessage(struct soap *soap, const struct __ns1__sentMessage *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__sentMessage(soap, tag?tag:"-ns1:sentMessage", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sentMessage * SOAP_FMAC4 soap_get___ns1__sentMessage(struct soap *soap, struct __ns1__sentMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__sentMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__totalRegister(struct soap *soap, struct __ns1__totalRegister *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__totalRegister = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__totalRegister(struct soap *soap, const struct __ns1__totalRegister *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__totalRegister(soap, &a->ns1__totalRegister);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__totalRegister(struct soap *soap, const char *tag, int id, const struct __ns1__totalRegister *a, const char *type)
{
	if (soap_out_PointerTons1__totalRegister(soap, "ns1:totalRegister", -1, &a->ns1__totalRegister, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__totalRegister * SOAP_FMAC4 soap_in___ns1__totalRegister(struct soap *soap, const char *tag, struct __ns1__totalRegister *a, const char *type)
{
	size_t soap_flag_ns1__totalRegister = 1;
	short soap_flag;
	a = (struct __ns1__totalRegister *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__totalRegister, sizeof(struct __ns1__totalRegister), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__totalRegister(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__totalRegister && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__totalRegister(soap, "ns1:totalRegister", &a->ns1__totalRegister, "ns1:totalRegister"))
				{	soap_flag_ns1__totalRegister--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__totalRegister(struct soap *soap, const struct __ns1__totalRegister *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__totalRegister(soap, tag?tag:"-ns1:totalRegister", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__totalRegister * SOAP_FMAC4 soap_get___ns1__totalRegister(struct soap *soap, struct __ns1__totalRegister *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__totalRegister(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__invalidRegister(struct soap *soap, struct __ns1__invalidRegister *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__invalidRegister = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__invalidRegister(struct soap *soap, const struct __ns1__invalidRegister *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__invalidRegister(soap, &a->ns1__invalidRegister);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__invalidRegister(struct soap *soap, const char *tag, int id, const struct __ns1__invalidRegister *a, const char *type)
{
	if (soap_out_PointerTons1__invalidRegister(soap, "ns1:invalidRegister", -1, &a->ns1__invalidRegister, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__invalidRegister * SOAP_FMAC4 soap_in___ns1__invalidRegister(struct soap *soap, const char *tag, struct __ns1__invalidRegister *a, const char *type)
{
	size_t soap_flag_ns1__invalidRegister = 1;
	short soap_flag;
	a = (struct __ns1__invalidRegister *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__invalidRegister, sizeof(struct __ns1__invalidRegister), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__invalidRegister(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__invalidRegister && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__invalidRegister(soap, "ns1:invalidRegister", &a->ns1__invalidRegister, "ns1:invalidRegister"))
				{	soap_flag_ns1__invalidRegister--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__invalidRegister(struct soap *soap, const struct __ns1__invalidRegister *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__invalidRegister(soap, tag?tag:"-ns1:invalidRegister", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__invalidRegister * SOAP_FMAC4 soap_get___ns1__invalidRegister(struct soap *soap, struct __ns1__invalidRegister *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__invalidRegister(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__validRegister(struct soap *soap, struct __ns1__validRegister *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__validRegister = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__validRegister(struct soap *soap, const struct __ns1__validRegister *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__validRegister(soap, &a->ns1__validRegister);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__validRegister(struct soap *soap, const char *tag, int id, const struct __ns1__validRegister *a, const char *type)
{
	if (soap_out_PointerTons1__validRegister(soap, "ns1:validRegister", -1, &a->ns1__validRegister, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__validRegister * SOAP_FMAC4 soap_in___ns1__validRegister(struct soap *soap, const char *tag, struct __ns1__validRegister *a, const char *type)
{
	size_t soap_flag_ns1__validRegister = 1;
	short soap_flag;
	a = (struct __ns1__validRegister *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__validRegister, sizeof(struct __ns1__validRegister), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__validRegister(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__validRegister && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__validRegister(soap, "ns1:validRegister", &a->ns1__validRegister, "ns1:validRegister"))
				{	soap_flag_ns1__validRegister--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__validRegister(struct soap *soap, const struct __ns1__validRegister *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__validRegister(soap, tag?tag:"-ns1:validRegister", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__validRegister * SOAP_FMAC4 soap_get___ns1__validRegister(struct soap *soap, struct __ns1__validRegister *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__validRegister(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__checkStatusMessage(struct soap *soap, struct __ns1__checkStatusMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__checkStatusMessage = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__checkStatusMessage(struct soap *soap, const struct __ns1__checkStatusMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__checkStatusMessage(soap, &a->ns1__checkStatusMessage);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__checkStatusMessage(struct soap *soap, const char *tag, int id, const struct __ns1__checkStatusMessage *a, const char *type)
{
	if (soap_out_PointerTons1__checkStatusMessage(soap, "ns1:checkStatusMessage", -1, &a->ns1__checkStatusMessage, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkStatusMessage * SOAP_FMAC4 soap_in___ns1__checkStatusMessage(struct soap *soap, const char *tag, struct __ns1__checkStatusMessage *a, const char *type)
{
	size_t soap_flag_ns1__checkStatusMessage = 1;
	short soap_flag;
	a = (struct __ns1__checkStatusMessage *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__checkStatusMessage, sizeof(struct __ns1__checkStatusMessage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__checkStatusMessage(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__checkStatusMessage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__checkStatusMessage(soap, "ns1:checkStatusMessage", &a->ns1__checkStatusMessage, "ns1:checkStatusMessage"))
				{	soap_flag_ns1__checkStatusMessage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__checkStatusMessage(struct soap *soap, const struct __ns1__checkStatusMessage *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__checkStatusMessage(soap, tag?tag:"-ns1:checkStatusMessage", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkStatusMessage * SOAP_FMAC4 soap_get___ns1__checkStatusMessage(struct soap *soap, struct __ns1__checkStatusMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__checkStatusMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__checkStatus(struct soap *soap, struct __ns1__checkStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__checkStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__checkStatus(struct soap *soap, const struct __ns1__checkStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__checkStatus(soap, &a->ns1__checkStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__checkStatus(struct soap *soap, const char *tag, int id, const struct __ns1__checkStatus *a, const char *type)
{
	if (soap_out_PointerTons1__checkStatus(soap, "ns1:checkStatus", -1, &a->ns1__checkStatus, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkStatus * SOAP_FMAC4 soap_in___ns1__checkStatus(struct soap *soap, const char *tag, struct __ns1__checkStatus *a, const char *type)
{
	size_t soap_flag_ns1__checkStatus = 1;
	short soap_flag;
	a = (struct __ns1__checkStatus *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__checkStatus, sizeof(struct __ns1__checkStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__checkStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__checkStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__checkStatus(soap, "ns1:checkStatus", &a->ns1__checkStatus, "ns1:checkStatus"))
				{	soap_flag_ns1__checkStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__checkStatus(struct soap *soap, const struct __ns1__checkStatus *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__checkStatus(soap, tag?tag:"-ns1:checkStatus", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkStatus * SOAP_FMAC4 soap_get___ns1__checkStatus(struct soap *soap, struct __ns1__checkStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__checkStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__send(struct soap *soap, struct __ns1__send *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__send = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__send(struct soap *soap, const struct __ns1__send *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__send(soap, &a->ns1__send);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__send(struct soap *soap, const char *tag, int id, const struct __ns1__send *a, const char *type)
{
	if (soap_out_PointerTons1__send(soap, "ns1:send", -1, &a->ns1__send, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__send * SOAP_FMAC4 soap_in___ns1__send(struct soap *soap, const char *tag, struct __ns1__send *a, const char *type)
{
	size_t soap_flag_ns1__send = 1;
	short soap_flag;
	a = (struct __ns1__send *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__send, sizeof(struct __ns1__send), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__send(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__send && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__send(soap, "ns1:send", &a->ns1__send, "ns1:send"))
				{	soap_flag_ns1__send--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__send(struct soap *soap, const struct __ns1__send *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__send(soap, tag?tag:"-ns1:send", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__send * SOAP_FMAC4 soap_get___ns1__send(struct soap *soap, struct __ns1__send *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__send(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->ns1__BatchException = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__BatchException(soap, &a->ns1__BatchException);
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_out_PointerTons1__BatchException(soap, "ns1:BatchException", -1, &a->ns1__BatchException, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_ns1__BatchException = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__BatchException && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__BatchException(soap, "ns1:BatchException", &a->ns1__BatchException, "ns1:BatchException"))
				{	soap_flag_ns1__BatchException--;
					continue;
				}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__invalidRegisterResponse(struct soap *soap, struct ns1__invalidRegisterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__invalidRegisterResponse(struct soap *soap, const struct ns1__invalidRegisterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__invalidRegisterResponse(struct soap *soap, const char *tag, int id, const struct ns1__invalidRegisterResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__invalidRegisterResponse), type))
		return soap->error;
	if (soap_out_int(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__invalidRegisterResponse * SOAP_FMAC4 soap_in_ns1__invalidRegisterResponse(struct soap *soap, const char *tag, struct ns1__invalidRegisterResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__invalidRegisterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__invalidRegisterResponse, sizeof(struct ns1__invalidRegisterResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__invalidRegisterResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "return", &a->return_, "xsd:int"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__invalidRegisterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__invalidRegisterResponse, 0, sizeof(struct ns1__invalidRegisterResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__invalidRegisterResponse(struct soap *soap, const struct ns1__invalidRegisterResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__invalidRegisterResponse);
	if (soap_out_ns1__invalidRegisterResponse(soap, tag?tag:"ns1:invalidRegisterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__invalidRegisterResponse * SOAP_FMAC4 soap_get_ns1__invalidRegisterResponse(struct soap *soap, struct ns1__invalidRegisterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__invalidRegisterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__invalidRegister(struct soap *soap, struct ns1__invalidRegister *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->client);
	soap_default_string(soap, &a->user);
	soap_default_string(soap, &a->password);
	soap_default_int(soap, &a->idBatch);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__invalidRegister(struct soap *soap, const struct ns1__invalidRegister *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->client);
	soap_serialize_string(soap, &a->user);
	soap_serialize_string(soap, &a->password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__invalidRegister(struct soap *soap, const char *tag, int id, const struct ns1__invalidRegister *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__invalidRegister), type))
		return soap->error;
	if (soap_out_string(soap, "client", -1, &a->client, ""))
		return soap->error;
	if (soap_out_string(soap, "user", -1, &a->user, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_int(soap, "idBatch", -1, &a->idBatch, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__invalidRegister * SOAP_FMAC4 soap_in_ns1__invalidRegister(struct soap *soap, const char *tag, struct ns1__invalidRegister *a, const char *type)
{
	size_t soap_flag_client = 1;
	size_t soap_flag_user = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_idBatch = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__invalidRegister *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__invalidRegister, sizeof(struct ns1__invalidRegister), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__invalidRegister(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_client && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "client", &a->client, "xsd:string"))
				{	soap_flag_client--;
					continue;
				}
			if (soap_flag_user && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user", &a->user, "xsd:string"))
				{	soap_flag_user--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_idBatch && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idBatch", &a->idBatch, "xsd:int"))
				{	soap_flag_idBatch--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__invalidRegister *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__invalidRegister, 0, sizeof(struct ns1__invalidRegister), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idBatch > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__invalidRegister(struct soap *soap, const struct ns1__invalidRegister *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__invalidRegister);
	if (soap_out_ns1__invalidRegister(soap, tag?tag:"ns1:invalidRegister", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__invalidRegister * SOAP_FMAC4 soap_get_ns1__invalidRegister(struct soap *soap, struct ns1__invalidRegister *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__invalidRegister(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__sendResponse(struct soap *soap, struct ns1__sendResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__sendResponse(struct soap *soap, const struct ns1__sendResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sendResponse(struct soap *soap, const char *tag, int id, const struct ns1__sendResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__sendResponse), type))
		return soap->error;
	if (soap_out_int(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__sendResponse * SOAP_FMAC4 soap_in_ns1__sendResponse(struct soap *soap, const char *tag, struct ns1__sendResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__sendResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__sendResponse, sizeof(struct ns1__sendResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__sendResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "return", &a->return_, "xsd:int"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__sendResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__sendResponse, 0, sizeof(struct ns1__sendResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__sendResponse(struct soap *soap, const struct ns1__sendResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__sendResponse);
	if (soap_out_ns1__sendResponse(soap, tag?tag:"ns1:sendResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__sendResponse * SOAP_FMAC4 soap_get_ns1__sendResponse(struct soap *soap, struct ns1__sendResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__sendResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__stringArray(struct soap *soap, struct ns3__stringArray *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeitem = 0;
	a->item = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__stringArray(struct soap *soap, const struct ns3__stringArray *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->item)
	{	int i;
		for (i = 0; i < a->__sizeitem; i++)
		{
			soap_serialize_string(soap, a->item + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__stringArray(struct soap *soap, const char *tag, int id, const struct ns3__stringArray *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__stringArray), type))
		return soap->error;
	if (a->item)
	{	int i;
		for (i = 0; i < a->__sizeitem; i++)
			if (soap_out_string(soap, "item", -1, a->item + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__stringArray * SOAP_FMAC4 soap_in_ns3__stringArray(struct soap *soap, const char *tag, struct ns3__stringArray *a, const char *type)
{
	struct soap_blist *soap_blist_item = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__stringArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__stringArray, sizeof(struct ns3__stringArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__stringArray(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "item", 1, NULL))
			{	if (a->item == NULL)
				{	if (soap_blist_item == NULL)
						soap_blist_item = soap_new_block(soap);
					a->item = (char **)soap_push_block(soap, soap_blist_item, sizeof(char *));
					if (a->item == NULL)
						return NULL;
					*a->item = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "item", a->item, "xsd:string"))
				{	a->__sizeitem++;
					a->item = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->item)
			soap_pop_block(soap, soap_blist_item);
		if (a->__sizeitem)
			a->item = (char **)soap_save_block(soap, soap_blist_item, NULL, 1);
		else
		{	a->item = NULL;
			if (soap_blist_item)
				soap_end_block(soap, soap_blist_item);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__stringArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__stringArray, 0, sizeof(struct ns3__stringArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__stringArray(struct soap *soap, const struct ns3__stringArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__stringArray);
	if (soap_out_ns3__stringArray(soap, tag?tag:"ns3:stringArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__stringArray * SOAP_FMAC4 soap_get_ns3__stringArray(struct soap *soap, struct ns3__stringArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__stringArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__send(struct soap *soap, struct ns1__send *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->client);
	soap_default_string(soap, &a->user);
	soap_default_string(soap, &a->password);
	soap_default_string(soap, &a->startTime);
	soap_default_string(soap, &a->endTime);
	a->__sizefile = 0;
	a->file = NULL;
	soap_default_int(soap, &a->idMessage);
	soap_default_string(soap, &a->mail);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__send(struct soap *soap, const struct ns1__send *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->client);
	soap_serialize_string(soap, &a->user);
	soap_serialize_string(soap, &a->password);
	soap_serialize_string(soap, &a->startTime);
	soap_serialize_string(soap, &a->endTime);
	if (a->file)
	{	int i;
		for (i = 0; i < a->__sizefile; i++)
		{
			soap_embedded(soap, a->file + i, SOAP_TYPE_ns3__stringArray);
			soap_serialize_ns3__stringArray(soap, a->file + i);
		}
	}
	soap_serialize_string(soap, &a->mail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__send(struct soap *soap, const char *tag, int id, const struct ns1__send *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__send), type))
		return soap->error;
	if (soap_out_string(soap, "client", -1, &a->client, ""))
		return soap->error;
	if (soap_out_string(soap, "user", -1, &a->user, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_string(soap, "startTime", -1, &a->startTime, ""))
		return soap->error;
	if (soap_out_string(soap, "endTime", -1, &a->endTime, ""))
		return soap->error;
	if (a->file)
	{	int i;
		for (i = 0; i < a->__sizefile; i++)
			if (soap_out_ns3__stringArray(soap, "file", -1, a->file + i, ""))
				return soap->error;
	}
	if (soap_out_int(soap, "idMessage", -1, &a->idMessage, ""))
		return soap->error;
	if (soap_out_string(soap, "mail", -1, &a->mail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__send * SOAP_FMAC4 soap_in_ns1__send(struct soap *soap, const char *tag, struct ns1__send *a, const char *type)
{
	size_t soap_flag_client = 1;
	size_t soap_flag_user = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_startTime = 1;
	size_t soap_flag_endTime = 1;
	struct soap_blist *soap_blist_file = NULL;
	size_t soap_flag_idMessage = 1;
	size_t soap_flag_mail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__send *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__send, sizeof(struct ns1__send), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__send(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_client && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "client", &a->client, "xsd:string"))
				{	soap_flag_client--;
					continue;
				}
			if (soap_flag_user && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user", &a->user, "xsd:string"))
				{	soap_flag_user--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_startTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "startTime", &a->startTime, "xsd:string"))
				{	soap_flag_startTime--;
					continue;
				}
			if (soap_flag_endTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "endTime", &a->endTime, "xsd:string"))
				{	soap_flag_endTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "file", 1, NULL))
			{	if (a->file == NULL)
				{	if (soap_blist_file == NULL)
						soap_blist_file = soap_new_block(soap);
					a->file = (struct ns3__stringArray *)soap_push_block(soap, soap_blist_file, sizeof(struct ns3__stringArray));
					if (a->file == NULL)
						return NULL;
					soap_default_ns3__stringArray(soap, a->file);
				}
				soap_revert(soap);
				if (soap_in_ns3__stringArray(soap, "file", a->file, "ns3:stringArray"))
				{	a->__sizefile++;
					a->file = NULL;
					continue;
				}
			}
			if (soap_flag_idMessage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idMessage", &a->idMessage, "xsd:int"))
				{	soap_flag_idMessage--;
					continue;
				}
			if (soap_flag_mail && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "mail", &a->mail, "xsd:string"))
				{	soap_flag_mail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->file)
			soap_pop_block(soap, soap_blist_file);
		if (a->__sizefile)
			a->file = (struct ns3__stringArray *)soap_save_block(soap, soap_blist_file, NULL, 1);
		else
		{	a->file = NULL;
			if (soap_blist_file)
				soap_end_block(soap, soap_blist_file);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__send *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__send, 0, sizeof(struct ns1__send), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idMessage > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__send(struct soap *soap, const struct ns1__send *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__send);
	if (soap_out_ns1__send(soap, tag?tag:"ns1:send", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__send * SOAP_FMAC4 soap_get_ns1__send(struct soap *soap, struct ns1__send *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__send(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__checkStatusResponse(struct soap *soap, struct ns1__checkStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__checkStatusResponse(struct soap *soap, const struct ns1__checkStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__checkStatusResponse(struct soap *soap, const char *tag, int id, const struct ns1__checkStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__checkStatusResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__checkStatusResponse * SOAP_FMAC4 soap_in_ns1__checkStatusResponse(struct soap *soap, const char *tag, struct ns1__checkStatusResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__checkStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__checkStatusResponse, sizeof(struct ns1__checkStatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__checkStatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__checkStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__checkStatusResponse, 0, sizeof(struct ns1__checkStatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__checkStatusResponse(struct soap *soap, const struct ns1__checkStatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__checkStatusResponse);
	if (soap_out_ns1__checkStatusResponse(soap, tag?tag:"ns1:checkStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__checkStatusResponse * SOAP_FMAC4 soap_get_ns1__checkStatusResponse(struct soap *soap, struct ns1__checkStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__checkStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__checkStatus(struct soap *soap, struct ns1__checkStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->client);
	soap_default_string(soap, &a->user);
	soap_default_string(soap, &a->password);
	soap_default_int(soap, &a->idBatch);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__checkStatus(struct soap *soap, const struct ns1__checkStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->client);
	soap_serialize_string(soap, &a->user);
	soap_serialize_string(soap, &a->password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__checkStatus(struct soap *soap, const char *tag, int id, const struct ns1__checkStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__checkStatus), type))
		return soap->error;
	if (soap_out_string(soap, "client", -1, &a->client, ""))
		return soap->error;
	if (soap_out_string(soap, "user", -1, &a->user, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_int(soap, "idBatch", -1, &a->idBatch, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__checkStatus * SOAP_FMAC4 soap_in_ns1__checkStatus(struct soap *soap, const char *tag, struct ns1__checkStatus *a, const char *type)
{
	size_t soap_flag_client = 1;
	size_t soap_flag_user = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_idBatch = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__checkStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__checkStatus, sizeof(struct ns1__checkStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__checkStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_client && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "client", &a->client, "xsd:string"))
				{	soap_flag_client--;
					continue;
				}
			if (soap_flag_user && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user", &a->user, "xsd:string"))
				{	soap_flag_user--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_idBatch && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idBatch", &a->idBatch, "xsd:int"))
				{	soap_flag_idBatch--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__checkStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__checkStatus, 0, sizeof(struct ns1__checkStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idBatch > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__checkStatus(struct soap *soap, const struct ns1__checkStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__checkStatus);
	if (soap_out_ns1__checkStatus(soap, tag?tag:"ns1:checkStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__checkStatus * SOAP_FMAC4 soap_get_ns1__checkStatus(struct soap *soap, struct ns1__checkStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__checkStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__validRegisterResponse(struct soap *soap, struct ns1__validRegisterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__validRegisterResponse(struct soap *soap, const struct ns1__validRegisterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__validRegisterResponse(struct soap *soap, const char *tag, int id, const struct ns1__validRegisterResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__validRegisterResponse), type))
		return soap->error;
	if (soap_out_int(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__validRegisterResponse * SOAP_FMAC4 soap_in_ns1__validRegisterResponse(struct soap *soap, const char *tag, struct ns1__validRegisterResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__validRegisterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__validRegisterResponse, sizeof(struct ns1__validRegisterResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__validRegisterResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "return", &a->return_, "xsd:int"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__validRegisterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__validRegisterResponse, 0, sizeof(struct ns1__validRegisterResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__validRegisterResponse(struct soap *soap, const struct ns1__validRegisterResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__validRegisterResponse);
	if (soap_out_ns1__validRegisterResponse(soap, tag?tag:"ns1:validRegisterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__validRegisterResponse * SOAP_FMAC4 soap_get_ns1__validRegisterResponse(struct soap *soap, struct ns1__validRegisterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__validRegisterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__validRegister(struct soap *soap, struct ns1__validRegister *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->client);
	soap_default_string(soap, &a->user);
	soap_default_string(soap, &a->password);
	soap_default_int(soap, &a->idBatch);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__validRegister(struct soap *soap, const struct ns1__validRegister *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->client);
	soap_serialize_string(soap, &a->user);
	soap_serialize_string(soap, &a->password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__validRegister(struct soap *soap, const char *tag, int id, const struct ns1__validRegister *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__validRegister), type))
		return soap->error;
	if (soap_out_string(soap, "client", -1, &a->client, ""))
		return soap->error;
	if (soap_out_string(soap, "user", -1, &a->user, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_int(soap, "idBatch", -1, &a->idBatch, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__validRegister * SOAP_FMAC4 soap_in_ns1__validRegister(struct soap *soap, const char *tag, struct ns1__validRegister *a, const char *type)
{
	size_t soap_flag_client = 1;
	size_t soap_flag_user = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_idBatch = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__validRegister *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__validRegister, sizeof(struct ns1__validRegister), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__validRegister(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_client && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "client", &a->client, "xsd:string"))
				{	soap_flag_client--;
					continue;
				}
			if (soap_flag_user && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user", &a->user, "xsd:string"))
				{	soap_flag_user--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_idBatch && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idBatch", &a->idBatch, "xsd:int"))
				{	soap_flag_idBatch--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__validRegister *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__validRegister, 0, sizeof(struct ns1__validRegister), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idBatch > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__validRegister(struct soap *soap, const struct ns1__validRegister *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__validRegister);
	if (soap_out_ns1__validRegister(soap, tag?tag:"ns1:validRegister", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__validRegister * SOAP_FMAC4 soap_get_ns1__validRegister(struct soap *soap, struct ns1__validRegister *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__validRegister(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__sentMessageResponse(struct soap *soap, struct ns1__sentMessageResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__sentMessageResponse(struct soap *soap, const struct ns1__sentMessageResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sentMessageResponse(struct soap *soap, const char *tag, int id, const struct ns1__sentMessageResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__sentMessageResponse), type))
		return soap->error;
	if (soap_out_int(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__sentMessageResponse * SOAP_FMAC4 soap_in_ns1__sentMessageResponse(struct soap *soap, const char *tag, struct ns1__sentMessageResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__sentMessageResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__sentMessageResponse, sizeof(struct ns1__sentMessageResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__sentMessageResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "return", &a->return_, "xsd:int"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__sentMessageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__sentMessageResponse, 0, sizeof(struct ns1__sentMessageResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__sentMessageResponse(struct soap *soap, const struct ns1__sentMessageResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__sentMessageResponse);
	if (soap_out_ns1__sentMessageResponse(soap, tag?tag:"ns1:sentMessageResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__sentMessageResponse * SOAP_FMAC4 soap_get_ns1__sentMessageResponse(struct soap *soap, struct ns1__sentMessageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__sentMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__sentMessage(struct soap *soap, struct ns1__sentMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->client);
	soap_default_string(soap, &a->user);
	soap_default_string(soap, &a->password);
	soap_default_int(soap, &a->idBatch);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__sentMessage(struct soap *soap, const struct ns1__sentMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->client);
	soap_serialize_string(soap, &a->user);
	soap_serialize_string(soap, &a->password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sentMessage(struct soap *soap, const char *tag, int id, const struct ns1__sentMessage *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__sentMessage), type))
		return soap->error;
	if (soap_out_string(soap, "client", -1, &a->client, ""))
		return soap->error;
	if (soap_out_string(soap, "user", -1, &a->user, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_int(soap, "idBatch", -1, &a->idBatch, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__sentMessage * SOAP_FMAC4 soap_in_ns1__sentMessage(struct soap *soap, const char *tag, struct ns1__sentMessage *a, const char *type)
{
	size_t soap_flag_client = 1;
	size_t soap_flag_user = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_idBatch = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__sentMessage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__sentMessage, sizeof(struct ns1__sentMessage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__sentMessage(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_client && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "client", &a->client, "xsd:string"))
				{	soap_flag_client--;
					continue;
				}
			if (soap_flag_user && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user", &a->user, "xsd:string"))
				{	soap_flag_user--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_idBatch && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idBatch", &a->idBatch, "xsd:int"))
				{	soap_flag_idBatch--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__sentMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__sentMessage, 0, sizeof(struct ns1__sentMessage), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idBatch > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__sentMessage(struct soap *soap, const struct ns1__sentMessage *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__sentMessage);
	if (soap_out_ns1__sentMessage(soap, tag?tag:"ns1:sentMessage", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__sentMessage * SOAP_FMAC4 soap_get_ns1__sentMessage(struct soap *soap, struct ns1__sentMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__sentMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__checkStatusMessageResponse(struct soap *soap, struct ns1__checkStatusMessageResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__checkStatusMessageResponse(struct soap *soap, const struct ns1__checkStatusMessageResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__checkStatusMessageResponse(struct soap *soap, const char *tag, int id, const struct ns1__checkStatusMessageResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__checkStatusMessageResponse), type))
		return soap->error;
	if (soap_out_string(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__checkStatusMessageResponse * SOAP_FMAC4 soap_in_ns1__checkStatusMessageResponse(struct soap *soap, const char *tag, struct ns1__checkStatusMessageResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__checkStatusMessageResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__checkStatusMessageResponse, sizeof(struct ns1__checkStatusMessageResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__checkStatusMessageResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__checkStatusMessageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__checkStatusMessageResponse, 0, sizeof(struct ns1__checkStatusMessageResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__checkStatusMessageResponse(struct soap *soap, const struct ns1__checkStatusMessageResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__checkStatusMessageResponse);
	if (soap_out_ns1__checkStatusMessageResponse(soap, tag?tag:"ns1:checkStatusMessageResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__checkStatusMessageResponse * SOAP_FMAC4 soap_get_ns1__checkStatusMessageResponse(struct soap *soap, struct ns1__checkStatusMessageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__checkStatusMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__checkStatusMessage(struct soap *soap, struct ns1__checkStatusMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->client);
	soap_default_string(soap, &a->user);
	soap_default_string(soap, &a->password);
	soap_default_int(soap, &a->idMessage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__checkStatusMessage(struct soap *soap, const struct ns1__checkStatusMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->client);
	soap_serialize_string(soap, &a->user);
	soap_serialize_string(soap, &a->password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__checkStatusMessage(struct soap *soap, const char *tag, int id, const struct ns1__checkStatusMessage *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__checkStatusMessage), type))
		return soap->error;
	if (soap_out_string(soap, "client", -1, &a->client, ""))
		return soap->error;
	if (soap_out_string(soap, "user", -1, &a->user, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_int(soap, "idMessage", -1, &a->idMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__checkStatusMessage * SOAP_FMAC4 soap_in_ns1__checkStatusMessage(struct soap *soap, const char *tag, struct ns1__checkStatusMessage *a, const char *type)
{
	size_t soap_flag_client = 1;
	size_t soap_flag_user = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_idMessage = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__checkStatusMessage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__checkStatusMessage, sizeof(struct ns1__checkStatusMessage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__checkStatusMessage(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_client && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "client", &a->client, "xsd:string"))
				{	soap_flag_client--;
					continue;
				}
			if (soap_flag_user && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user", &a->user, "xsd:string"))
				{	soap_flag_user--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_idMessage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idMessage", &a->idMessage, "xsd:int"))
				{	soap_flag_idMessage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__checkStatusMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__checkStatusMessage, 0, sizeof(struct ns1__checkStatusMessage), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idMessage > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__checkStatusMessage(struct soap *soap, const struct ns1__checkStatusMessage *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__checkStatusMessage);
	if (soap_out_ns1__checkStatusMessage(soap, tag?tag:"ns1:checkStatusMessage", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__checkStatusMessage * SOAP_FMAC4 soap_get_ns1__checkStatusMessage(struct soap *soap, struct ns1__checkStatusMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__checkStatusMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__BatchException(struct soap *soap, struct ns1__BatchException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__BatchException(struct soap *soap, const struct ns1__BatchException *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->message);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BatchException(struct soap *soap, const char *tag, int id, const struct ns1__BatchException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BatchException), type))
		return soap->error;
	if (soap_out_string(soap, "message", -1, &a->message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__BatchException * SOAP_FMAC4 soap_in_ns1__BatchException(struct soap *soap, const char *tag, struct ns1__BatchException *a, const char *type)
{
	size_t soap_flag_message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__BatchException *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BatchException, sizeof(struct ns1__BatchException), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__BatchException(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "message", &a->message, "xsd:string"))
				{	soap_flag_message--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__BatchException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BatchException, 0, sizeof(struct ns1__BatchException), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__BatchException(struct soap *soap, const struct ns1__BatchException *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__BatchException);
	if (soap_out_ns1__BatchException(soap, tag?tag:"ns1:BatchException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__BatchException * SOAP_FMAC4 soap_get_ns1__BatchException(struct soap *soap, struct ns1__BatchException *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BatchException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__totalRegisterResponse(struct soap *soap, struct ns1__totalRegisterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__totalRegisterResponse(struct soap *soap, const struct ns1__totalRegisterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__totalRegisterResponse(struct soap *soap, const char *tag, int id, const struct ns1__totalRegisterResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__totalRegisterResponse), type))
		return soap->error;
	if (soap_out_int(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__totalRegisterResponse * SOAP_FMAC4 soap_in_ns1__totalRegisterResponse(struct soap *soap, const char *tag, struct ns1__totalRegisterResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__totalRegisterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__totalRegisterResponse, sizeof(struct ns1__totalRegisterResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__totalRegisterResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "return", &a->return_, "xsd:int"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__totalRegisterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__totalRegisterResponse, 0, sizeof(struct ns1__totalRegisterResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__totalRegisterResponse(struct soap *soap, const struct ns1__totalRegisterResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__totalRegisterResponse);
	if (soap_out_ns1__totalRegisterResponse(soap, tag?tag:"ns1:totalRegisterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__totalRegisterResponse * SOAP_FMAC4 soap_get_ns1__totalRegisterResponse(struct soap *soap, struct ns1__totalRegisterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__totalRegisterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__totalRegister(struct soap *soap, struct ns1__totalRegister *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->client);
	soap_default_string(soap, &a->user);
	soap_default_string(soap, &a->password);
	soap_default_int(soap, &a->idBatch);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__totalRegister(struct soap *soap, const struct ns1__totalRegister *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->client);
	soap_serialize_string(soap, &a->user);
	soap_serialize_string(soap, &a->password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__totalRegister(struct soap *soap, const char *tag, int id, const struct ns1__totalRegister *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__totalRegister), type))
		return soap->error;
	if (soap_out_string(soap, "client", -1, &a->client, ""))
		return soap->error;
	if (soap_out_string(soap, "user", -1, &a->user, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_int(soap, "idBatch", -1, &a->idBatch, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__totalRegister * SOAP_FMAC4 soap_in_ns1__totalRegister(struct soap *soap, const char *tag, struct ns1__totalRegister *a, const char *type)
{
	size_t soap_flag_client = 1;
	size_t soap_flag_user = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_idBatch = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__totalRegister *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__totalRegister, sizeof(struct ns1__totalRegister), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__totalRegister(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_client && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "client", &a->client, "xsd:string"))
				{	soap_flag_client--;
					continue;
				}
			if (soap_flag_user && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user", &a->user, "xsd:string"))
				{	soap_flag_user--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_idBatch && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "idBatch", &a->idBatch, "xsd:int"))
				{	soap_flag_idBatch--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__totalRegister *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__totalRegister, 0, sizeof(struct ns1__totalRegister), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_idBatch > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__totalRegister(struct soap *soap, const struct ns1__totalRegister *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__totalRegister);
	if (soap_out_ns1__totalRegister(soap, tag?tag:"ns1:totalRegister", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__totalRegister * SOAP_FMAC4 soap_get_ns1__totalRegister(struct soap *soap, struct ns1__totalRegister *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__totalRegister(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__sentMessageResponse(struct soap *soap, struct ns1__sentMessageResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__sentMessageResponse))
		soap_serialize_ns1__sentMessageResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__sentMessageResponse(struct soap *soap, const char *tag, int id, struct ns1__sentMessageResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__sentMessageResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__sentMessageResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__sentMessageResponse ** SOAP_FMAC4 soap_in_PointerTons1__sentMessageResponse(struct soap *soap, const char *tag, struct ns1__sentMessageResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__sentMessageResponse **)soap_malloc(soap, sizeof(struct ns1__sentMessageResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__sentMessageResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__sentMessageResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__sentMessageResponse, sizeof(struct ns1__sentMessageResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__sentMessageResponse(struct soap *soap, struct ns1__sentMessageResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__sentMessageResponse);
	if (soap_out_PointerTons1__sentMessageResponse(soap, tag?tag:"ns1:sentMessageResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__sentMessageResponse ** SOAP_FMAC4 soap_get_PointerTons1__sentMessageResponse(struct soap *soap, struct ns1__sentMessageResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__sentMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__sentMessage(struct soap *soap, struct ns1__sentMessage *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__sentMessage))
		soap_serialize_ns1__sentMessage(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__sentMessage(struct soap *soap, const char *tag, int id, struct ns1__sentMessage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__sentMessage);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__sentMessage(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__sentMessage ** SOAP_FMAC4 soap_in_PointerTons1__sentMessage(struct soap *soap, const char *tag, struct ns1__sentMessage **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__sentMessage **)soap_malloc(soap, sizeof(struct ns1__sentMessage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__sentMessage(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__sentMessage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__sentMessage, sizeof(struct ns1__sentMessage), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__sentMessage(struct soap *soap, struct ns1__sentMessage *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__sentMessage);
	if (soap_out_PointerTons1__sentMessage(soap, tag?tag:"ns1:sentMessage", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__sentMessage ** SOAP_FMAC4 soap_get_PointerTons1__sentMessage(struct soap *soap, struct ns1__sentMessage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__sentMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__totalRegisterResponse(struct soap *soap, struct ns1__totalRegisterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__totalRegisterResponse))
		soap_serialize_ns1__totalRegisterResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__totalRegisterResponse(struct soap *soap, const char *tag, int id, struct ns1__totalRegisterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__totalRegisterResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__totalRegisterResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__totalRegisterResponse ** SOAP_FMAC4 soap_in_PointerTons1__totalRegisterResponse(struct soap *soap, const char *tag, struct ns1__totalRegisterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__totalRegisterResponse **)soap_malloc(soap, sizeof(struct ns1__totalRegisterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__totalRegisterResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__totalRegisterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__totalRegisterResponse, sizeof(struct ns1__totalRegisterResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__totalRegisterResponse(struct soap *soap, struct ns1__totalRegisterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__totalRegisterResponse);
	if (soap_out_PointerTons1__totalRegisterResponse(soap, tag?tag:"ns1:totalRegisterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__totalRegisterResponse ** SOAP_FMAC4 soap_get_PointerTons1__totalRegisterResponse(struct soap *soap, struct ns1__totalRegisterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__totalRegisterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__totalRegister(struct soap *soap, struct ns1__totalRegister *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__totalRegister))
		soap_serialize_ns1__totalRegister(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__totalRegister(struct soap *soap, const char *tag, int id, struct ns1__totalRegister *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__totalRegister);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__totalRegister(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__totalRegister ** SOAP_FMAC4 soap_in_PointerTons1__totalRegister(struct soap *soap, const char *tag, struct ns1__totalRegister **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__totalRegister **)soap_malloc(soap, sizeof(struct ns1__totalRegister *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__totalRegister(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__totalRegister **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__totalRegister, sizeof(struct ns1__totalRegister), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__totalRegister(struct soap *soap, struct ns1__totalRegister *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__totalRegister);
	if (soap_out_PointerTons1__totalRegister(soap, tag?tag:"ns1:totalRegister", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__totalRegister ** SOAP_FMAC4 soap_get_PointerTons1__totalRegister(struct soap *soap, struct ns1__totalRegister **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__totalRegister(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__invalidRegisterResponse(struct soap *soap, struct ns1__invalidRegisterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__invalidRegisterResponse))
		soap_serialize_ns1__invalidRegisterResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__invalidRegisterResponse(struct soap *soap, const char *tag, int id, struct ns1__invalidRegisterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__invalidRegisterResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__invalidRegisterResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__invalidRegisterResponse ** SOAP_FMAC4 soap_in_PointerTons1__invalidRegisterResponse(struct soap *soap, const char *tag, struct ns1__invalidRegisterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__invalidRegisterResponse **)soap_malloc(soap, sizeof(struct ns1__invalidRegisterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__invalidRegisterResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__invalidRegisterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__invalidRegisterResponse, sizeof(struct ns1__invalidRegisterResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__invalidRegisterResponse(struct soap *soap, struct ns1__invalidRegisterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__invalidRegisterResponse);
	if (soap_out_PointerTons1__invalidRegisterResponse(soap, tag?tag:"ns1:invalidRegisterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__invalidRegisterResponse ** SOAP_FMAC4 soap_get_PointerTons1__invalidRegisterResponse(struct soap *soap, struct ns1__invalidRegisterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__invalidRegisterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__invalidRegister(struct soap *soap, struct ns1__invalidRegister *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__invalidRegister))
		soap_serialize_ns1__invalidRegister(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__invalidRegister(struct soap *soap, const char *tag, int id, struct ns1__invalidRegister *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__invalidRegister);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__invalidRegister(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__invalidRegister ** SOAP_FMAC4 soap_in_PointerTons1__invalidRegister(struct soap *soap, const char *tag, struct ns1__invalidRegister **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__invalidRegister **)soap_malloc(soap, sizeof(struct ns1__invalidRegister *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__invalidRegister(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__invalidRegister **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__invalidRegister, sizeof(struct ns1__invalidRegister), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__invalidRegister(struct soap *soap, struct ns1__invalidRegister *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__invalidRegister);
	if (soap_out_PointerTons1__invalidRegister(soap, tag?tag:"ns1:invalidRegister", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__invalidRegister ** SOAP_FMAC4 soap_get_PointerTons1__invalidRegister(struct soap *soap, struct ns1__invalidRegister **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__invalidRegister(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__validRegisterResponse(struct soap *soap, struct ns1__validRegisterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__validRegisterResponse))
		soap_serialize_ns1__validRegisterResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__validRegisterResponse(struct soap *soap, const char *tag, int id, struct ns1__validRegisterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__validRegisterResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__validRegisterResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__validRegisterResponse ** SOAP_FMAC4 soap_in_PointerTons1__validRegisterResponse(struct soap *soap, const char *tag, struct ns1__validRegisterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__validRegisterResponse **)soap_malloc(soap, sizeof(struct ns1__validRegisterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__validRegisterResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__validRegisterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__validRegisterResponse, sizeof(struct ns1__validRegisterResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__validRegisterResponse(struct soap *soap, struct ns1__validRegisterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__validRegisterResponse);
	if (soap_out_PointerTons1__validRegisterResponse(soap, tag?tag:"ns1:validRegisterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__validRegisterResponse ** SOAP_FMAC4 soap_get_PointerTons1__validRegisterResponse(struct soap *soap, struct ns1__validRegisterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__validRegisterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__validRegister(struct soap *soap, struct ns1__validRegister *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__validRegister))
		soap_serialize_ns1__validRegister(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__validRegister(struct soap *soap, const char *tag, int id, struct ns1__validRegister *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__validRegister);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__validRegister(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__validRegister ** SOAP_FMAC4 soap_in_PointerTons1__validRegister(struct soap *soap, const char *tag, struct ns1__validRegister **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__validRegister **)soap_malloc(soap, sizeof(struct ns1__validRegister *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__validRegister(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__validRegister **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__validRegister, sizeof(struct ns1__validRegister), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__validRegister(struct soap *soap, struct ns1__validRegister *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__validRegister);
	if (soap_out_PointerTons1__validRegister(soap, tag?tag:"ns1:validRegister", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__validRegister ** SOAP_FMAC4 soap_get_PointerTons1__validRegister(struct soap *soap, struct ns1__validRegister **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__validRegister(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__checkStatusMessageResponse(struct soap *soap, struct ns1__checkStatusMessageResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__checkStatusMessageResponse))
		soap_serialize_ns1__checkStatusMessageResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__checkStatusMessageResponse(struct soap *soap, const char *tag, int id, struct ns1__checkStatusMessageResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__checkStatusMessageResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__checkStatusMessageResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__checkStatusMessageResponse ** SOAP_FMAC4 soap_in_PointerTons1__checkStatusMessageResponse(struct soap *soap, const char *tag, struct ns1__checkStatusMessageResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__checkStatusMessageResponse **)soap_malloc(soap, sizeof(struct ns1__checkStatusMessageResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__checkStatusMessageResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__checkStatusMessageResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__checkStatusMessageResponse, sizeof(struct ns1__checkStatusMessageResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__checkStatusMessageResponse(struct soap *soap, struct ns1__checkStatusMessageResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__checkStatusMessageResponse);
	if (soap_out_PointerTons1__checkStatusMessageResponse(soap, tag?tag:"ns1:checkStatusMessageResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__checkStatusMessageResponse ** SOAP_FMAC4 soap_get_PointerTons1__checkStatusMessageResponse(struct soap *soap, struct ns1__checkStatusMessageResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__checkStatusMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__checkStatusMessage(struct soap *soap, struct ns1__checkStatusMessage *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__checkStatusMessage))
		soap_serialize_ns1__checkStatusMessage(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__checkStatusMessage(struct soap *soap, const char *tag, int id, struct ns1__checkStatusMessage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__checkStatusMessage);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__checkStatusMessage(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__checkStatusMessage ** SOAP_FMAC4 soap_in_PointerTons1__checkStatusMessage(struct soap *soap, const char *tag, struct ns1__checkStatusMessage **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__checkStatusMessage **)soap_malloc(soap, sizeof(struct ns1__checkStatusMessage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__checkStatusMessage(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__checkStatusMessage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__checkStatusMessage, sizeof(struct ns1__checkStatusMessage), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__checkStatusMessage(struct soap *soap, struct ns1__checkStatusMessage *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__checkStatusMessage);
	if (soap_out_PointerTons1__checkStatusMessage(soap, tag?tag:"ns1:checkStatusMessage", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__checkStatusMessage ** SOAP_FMAC4 soap_get_PointerTons1__checkStatusMessage(struct soap *soap, struct ns1__checkStatusMessage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__checkStatusMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__checkStatusResponse(struct soap *soap, struct ns1__checkStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__checkStatusResponse))
		soap_serialize_ns1__checkStatusResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__checkStatusResponse(struct soap *soap, const char *tag, int id, struct ns1__checkStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__checkStatusResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__checkStatusResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__checkStatusResponse ** SOAP_FMAC4 soap_in_PointerTons1__checkStatusResponse(struct soap *soap, const char *tag, struct ns1__checkStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__checkStatusResponse **)soap_malloc(soap, sizeof(struct ns1__checkStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__checkStatusResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__checkStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__checkStatusResponse, sizeof(struct ns1__checkStatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__checkStatusResponse(struct soap *soap, struct ns1__checkStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__checkStatusResponse);
	if (soap_out_PointerTons1__checkStatusResponse(soap, tag?tag:"ns1:checkStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__checkStatusResponse ** SOAP_FMAC4 soap_get_PointerTons1__checkStatusResponse(struct soap *soap, struct ns1__checkStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__checkStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__checkStatus(struct soap *soap, struct ns1__checkStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__checkStatus))
		soap_serialize_ns1__checkStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__checkStatus(struct soap *soap, const char *tag, int id, struct ns1__checkStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__checkStatus);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__checkStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__checkStatus ** SOAP_FMAC4 soap_in_PointerTons1__checkStatus(struct soap *soap, const char *tag, struct ns1__checkStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__checkStatus **)soap_malloc(soap, sizeof(struct ns1__checkStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__checkStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__checkStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__checkStatus, sizeof(struct ns1__checkStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__checkStatus(struct soap *soap, struct ns1__checkStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__checkStatus);
	if (soap_out_PointerTons1__checkStatus(soap, tag?tag:"ns1:checkStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__checkStatus ** SOAP_FMAC4 soap_get_PointerTons1__checkStatus(struct soap *soap, struct ns1__checkStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__checkStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__sendResponse(struct soap *soap, struct ns1__sendResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__sendResponse))
		soap_serialize_ns1__sendResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__sendResponse(struct soap *soap, const char *tag, int id, struct ns1__sendResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__sendResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__sendResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__sendResponse ** SOAP_FMAC4 soap_in_PointerTons1__sendResponse(struct soap *soap, const char *tag, struct ns1__sendResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__sendResponse **)soap_malloc(soap, sizeof(struct ns1__sendResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__sendResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__sendResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__sendResponse, sizeof(struct ns1__sendResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__sendResponse(struct soap *soap, struct ns1__sendResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__sendResponse);
	if (soap_out_PointerTons1__sendResponse(soap, tag?tag:"ns1:sendResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__sendResponse ** SOAP_FMAC4 soap_get_PointerTons1__sendResponse(struct soap *soap, struct ns1__sendResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__sendResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__send(struct soap *soap, struct ns1__send *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__send))
		soap_serialize_ns1__send(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__send(struct soap *soap, const char *tag, int id, struct ns1__send *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__send);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__send(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__send ** SOAP_FMAC4 soap_in_PointerTons1__send(struct soap *soap, const char *tag, struct ns1__send **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__send **)soap_malloc(soap, sizeof(struct ns1__send *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__send(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__send **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__send, sizeof(struct ns1__send), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__send(struct soap *soap, struct ns1__send *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__send);
	if (soap_out_PointerTons1__send(soap, tag?tag:"ns1:send", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__send ** SOAP_FMAC4 soap_get_PointerTons1__send(struct soap *soap, struct ns1__send **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__send(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BatchException(struct soap *soap, struct ns1__BatchException *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__BatchException))
		soap_serialize_ns1__BatchException(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BatchException(struct soap *soap, const char *tag, int id, struct ns1__BatchException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BatchException);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__BatchException(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__BatchException ** SOAP_FMAC4 soap_in_PointerTons1__BatchException(struct soap *soap, const char *tag, struct ns1__BatchException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__BatchException **)soap_malloc(soap, sizeof(struct ns1__BatchException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__BatchException(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__BatchException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BatchException, sizeof(struct ns1__BatchException), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BatchException(struct soap *soap, struct ns1__BatchException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__BatchException);
	if (soap_out_PointerTons1__BatchException(soap, tag?tag:"ns1:BatchException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__BatchException ** SOAP_FMAC4 soap_get_PointerTons1__BatchException(struct soap *soap, struct ns1__BatchException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BatchException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__stringArray(struct soap *soap, struct ns3__stringArray *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__stringArray))
		soap_serialize_ns3__stringArray(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__stringArray(struct soap *soap, const char *tag, int id, struct ns3__stringArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__stringArray);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__stringArray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns3__stringArray ** SOAP_FMAC4 soap_in_PointerTons3__stringArray(struct soap *soap, const char *tag, struct ns3__stringArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns3__stringArray **)soap_malloc(soap, sizeof(struct ns3__stringArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__stringArray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns3__stringArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__stringArray, sizeof(struct ns3__stringArray), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__stringArray(struct soap *soap, struct ns3__stringArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__stringArray);
	if (soap_out_PointerTons3__stringArray(soap, tag?tag:"ns3:stringArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__stringArray ** SOAP_FMAC4 soap_get_PointerTons3__stringArray(struct soap *soap, struct ns3__stringArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__stringArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
