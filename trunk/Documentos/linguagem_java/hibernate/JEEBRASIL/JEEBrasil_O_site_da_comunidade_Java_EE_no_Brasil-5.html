<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0037)http://www.jspbrasil.com.br/mostrar/3 -->
<HTML><STYLE>#gview-cmenu {
  position: absolute;
  border: 1px solid #ccc;
  background: #fff;
  margin: 0;
  padding: 0;
  top: 0;
  left: 0;
  z-index: 10000;
  list-style-type: none;
  -webkit-box-shadow: 0 3px 5px rgba(0, 0, 0, .5);
}

#gview-cmenu:focus {
  outline: none;
}

.gview-cmenu-item {
  margin: 0;
  padding: 5px 7px;
  cursor: default;
  font-size: 13px;
  font-family: arial, san-serif;
  color: #000;
  -webkit-user-select: none;
}

.gview-cmenu-item:hover {
  background-color: #F0F7F9;
}

.gview-cmenu-item:first-child {
  border-bottom: 1px solid #ddd;
}

.gview-hidden {
  display: none;
}
</STYLE><HEAD><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<TITLE>JEEBrasil -- O site da comunidade Java EE no Brasil</TITLE>

<SCRIPT type="text/javascript" src="./JEEBrasil_O_site_da_comunidade_Java_EE_no_Brasil-5_files/prototype.js"></SCRIPT>
<SCRIPT type="text/javascript" src="./JEEBrasil_O_site_da_comunidade_Java_EE_no_Brasil-5_files/effects.js"></SCRIPT>
<SCRIPT type="text/javascript" src="./JEEBrasil_O_site_da_comunidade_Java_EE_no_Brasil-5_files/validation.js"></SCRIPT>
<SCRIPT type="text/javascript" src="./JEEBrasil_O_site_da_comunidade_Java_EE_no_Brasil-5_files/votacao.js"></SCRIPT>
<SCRIPT type="text/javascript" src="./JEEBrasil_O_site_da_comunidade_Java_EE_no_Brasil-5_files/form.js"></SCRIPT>

<LINK href="./JEEBrasil_O_site_da_comunidade_Java_EE_no_Brasil-5_files/layout.css" rel="stylesheet" type="text/css">
<LINK href="./JEEBrasil_O_site_da_comunidade_Java_EE_no_Brasil-5_files/rating.css" rel="stylesheet" type="text/css">
<LINK href="./JEEBrasil_O_site_da_comunidade_Java_EE_no_Brasil-5_files/style.css" rel="stylesheet" type="text/css">
<LINK href="./JEEBrasil_O_site_da_comunidade_Java_EE_no_Brasil-5_files/forms.css" rel="stylesheet" type="text/css">
</HEAD><BODY>

<DIV id="page">

<!-- Cabeçalho -->
<DIV id="header">

	<DIV id="header-top">
		<H1> <A href="http://www.jspbrasil.com.br/">JEE<SPAN class="greenText">Brasil</SPAN></A> </H1>
		<H2> O site da comunidade Java EE no Brasil </H2>
	
		<DIV id="encontre">
			<H3> Encontre </H3>
			<FORM action="http://www.jspbrasil.com.br/find" method="post" id="buscaForm">
				<P>
				<INPUT id="campo" name="busca" type="text" size="26">
				<A href="http://www.jspbrasil.com.br/mostrar/3#" onclick="$(&#39;buscaForm&#39;).submit();"> Buscar </A>
				</P>
			</FORM>
		</DIV>
	</DIV>
	
	<DIV id="menu">
		<UL>
			<LI> <A href="http://www.jspbrasil.com.br/">Home</A> </LI>
			<LI> <A href="http://www.jspbrasil.com.br/noticias">Notícias</A> </LI>
			<LI> <A href="http://www.jspbrasil.com.br/eventos">Eventos</A> </LI>
			<LI> <A href="http://www.jspbrasil.com.br/artigos">Artigos</A> </LI>
			<LI> <A href="http://www.jspbrasil.com.br/tutoriais">Tutoriais</A> </LI>
			<LI> <A href="http://www.jspbrasil.com.br/tags">Tags</A> </LI>			
			<LI> <A href="http://www.jspbrasil.com.br/apresentacoes">Apresentações</A> </LI>
			<LI> <A href="http://www.jspbrasil.com.br/quemsomos">Quem Somos</A> </LI>	
			<LI id="areaRestrita"> <A href="http://www.jspbrasil.com.br/admin"><IMG src="./JEEBrasil_O_site_da_comunidade_Java_EE_no_Brasil-5_files/chave.gif" alt="Administra&ccedil;&atilde;o"></A></LI>			
		</UL>
	</DIV>
	
</DIV>

<DIV id="content">


	<DIV id="fullPanel">
		<DIV id="rightPanel">
			<H4 class="informacoes"> Informações </H4>
			<TABLE>
				<TBODY><TR>
					<TH> Tipo: </TH>
					<TD> Tutorial </TD>
				</TR>
				<TR>
					<TH> Data de Publicação: </TH>
					<TD> 27/08/2006 </TD>
				</TR>
				<TR>
					<TH> Revisado em:</TH>
					<TD> 27/08/2006 </TD>
				</TR>
			</TBODY></TABLE>
			<H4 class="nota" id="user-note">
				
				Vote!
				
				
			</H4>
			<UL class="star-rating" id="voting">
				<LI class="current-rating" id="current-rating" style="width: 108.25px">Currently 4,3/5 Stars.</LI>
				
				<LI><A href="http://www.jspbrasil.com.br/mostrar/3#" onclick="javascript:votar(3,1, &#39;&#39;);" title="muito ruim" class="one-star">1</A></LI>
				<LI><A href="http://www.jspbrasil.com.br/mostrar/3#" onclick="javascript:votar(3,2, &#39;&#39;);" title="ruim" class="two-stars">2</A></LI>
				<LI><A href="http://www.jspbrasil.com.br/mostrar/3#" onclick="javascript:votar(3,3, &#39;&#39;);" title="mais ou menos" class="three-stars">3</A></LI>
				<LI><A href="http://www.jspbrasil.com.br/mostrar/3#" onclick="javascript:votar(3,4, &#39;&#39;);" title="bom" class="four-stars">4</A></LI>
				<LI><A href="http://www.jspbrasil.com.br/mostrar/3#" onclick="javascript:votar(3,5, &#39;&#39;);" title="muito bom" class="five-stars">5</A></LI>
				
			</UL>
			
			<H4 class="tagsRelacionadas">Tags Relacionadas</H4>
			<P class="tags">
				
				<A href="http://www.jspbrasil.com.br/tags/hibernate">hibernate</A>
				
				<A href="http://www.jspbrasil.com.br/tags/framework">framework</A>
				
				<A href="http://www.jspbrasil.com.br/tags/persistencia">persistencia</A>
				
			</P>
			<H4 class="comentarios"><A href="http://www.jspbrasil.com.br/mostrar/3#comentarios">Comentários ( 9 )</A></H4>
			<H4 class="imprimir">Imprimir</H4>
		</DIV>

		<DIV id="tituloPublicacao">
			<H3> Transações com Hibernate </H3>
			<P class="autores">
				por:<BR>
				</P><P class="autor">
				
				Raphaela Galhardo Fernandes (raphaela@jeebrasil.com.br)<BR>
				
				Gleydson Lima (gleydson@jeebrasil.com.br)<BR>
				
				</P>
			<P></P>

			<P class="resumo">
			Nste artigo serão apresentados alguns conceitos relacionados a transações, bem como as mesmas são implementadas com o framework Hibernate.
			</P>

			<H4>  </H4>
		</DIV>

		<DIV id="corpoPublicacao">
			<H4>Introdução</H4>
		
<P>
Uma transação é uma unidade de execução indivisível (ou atômica). Isso significa dizer que todas as etapas pertencentes a uma transação são completamente finalizadas ou nenhuma delas termina.
</P>
<P>
Para exemplificar o conceito de transações, considere um exemplo clássico de transferência entre contas bancárias: transferir R$ 150,00 da conta corrente do cliente A para a conta corrente do cliente B. Basicamente, as operações que compõem a transação são:
</P>
		
<OL>
    <LI> Debitar R$ 150,00 da conta corrente do cliente A </LI>
    <LI>Creditar R$ 150,00 na conta corrente do cliente B</LI>
</OL>
		
<P>
Para a efetivação da transação descrita acima, seria necessário seguir os seguintes passos:
</P>
		
<OL>
	<LI> Ler o saldo da conta corrente A (xA)</LI>
	<LI> Calcular o débito de R$ 150,00 da conta corrente A (dA = xA – 150,00)</LI>
	<LI> Gravar na base de dados o novo saldo da conta corrente A (xA = dA)</LI>
	<LI> Ler o saldo da conta corrente B (xB)</LI>
	<LI> Calcular o crédito de R$ 150,00 na conta corrente B (dB = xB + 150,00)</LI>
	<LI> Gravar na base de dados o novo saldo da conta corrente B (xB = dB)</LI>
</OL>

<P>
Caso ocorra algum problema (por exemplo: falta de energia, falha no computador, falha no programa, etc.), 
a execução dos passos anteriores pode ser interrompida. Se, por exemplo, houvesse interrupção logo após a 
execução do 3º passo, a conta A teria um débito de R$ 150,00 e ainda não teria sido creditado R$ 150,00 
na conta corrente B. Neste caso, o banco de dados estaria em um estado inconsistente, afinal, R$ 150,00 
teriam “sumido” da conta A sem destino. Dessa maneira, é de suma importância garantir que esses seis 
passos sejam totalmente executados. Caso haja alguma falha antes da conclusão do último passo, deve-se 
garantir também que os passos já executados serão desfeitos, de forma que ou todos os passos são 
executados ou todos os passos não são executados. Para garantir a consistência do banco, esses seis 
passos devem ser executados dentro de uma transação, já que ela é uma unidade de execução atômica.
</P>
		
<P>
Resumindo, uma transação garante que a seqüência de operações dentro da mesma seja executada de forma única, 
ou seja, na ocorrência de erro em alguma das operações dentro da transação todas as operações realizadas desde o início 
podem ser revertidas e as alterações no banco de dados desfeitas, garantindo assim, a unicidade do processo.     
A transação pode ter dois fins: commit ou rollback.
</P>
		
<P>
Quando a transação sofre commit, todas as modificações nos dados realizadas pelas operações presentes na transação 
são salvas.  Quando a transação sofre rollback, todas as modificações nos dados realizadas pelas operações presentes 
na transação são desfeitas.
</P>
		
<P>
Para que um banco de dados garanta a integridade dos seus dados deve possuir quatro características, conhecidas como <STRONG>ACID</STRONG>:
</P>
		
<UL>
	<LI><STRONG>Atomicidade: </STRONG>o banco de dados deve garantir que todas as transações sejam indivisíveis.</LI>
	<LI><STRONG>Consistência: </STRONG>após a execução de uma transação, o banco de dados deve continuar consistente, ou seja, deve continuar com um estado válido.</LI>
	<LI><STRONG>Isolamento:</STRONG> mesmo que várias transações ocorram paralelamente (ou concorrentemente), nenhuma transação deve influenciar nas outras. Resultados parciais de uma transação não devem ser "vistos" por outras transações executadas concorrentemente.</LI>
	<LI><STRONG>Durabilidade: </STRONG>após a finalização de uma transação, todas as alterações feitas por ela no banco de dados devem ser duráveis, mesmo havendo falhas no sistema após a sua finalização.</LI>	
</UL>
		
<H4>Modelos de Transações</H4>
	
<P>
As definições do início de uma transação, de seu fim e das ações que devem ser tomadas na 
ocorrência de falhas são feitas através de um modelo de transação. Existem diversos modelos encontrados 
na literatura. Nesta seção serão abordados apenas quatro: <EM>Flat Transactions</EM>, <EM>Nested Transactions</EM>, 
<EM>Chained Transactions</EM> e <EM>Join Transactions</EM>.
</P>
		
<UL>
	<LI>
	<STRONG><EM>Flat Transaction.</EM></STRONG> Modelo mais utilizado pela maioria dos Sistemas Gerenciadores 
	de Banco de Dados (SGBD) e Gerenciadores de Transações. Conhecida como modelo de transações planas por 
	apresentar uma única camada de controle, ou seja, todas as operações dentro da transação são 
	tratadas como uma única unidade de trabalho.
	</LI>
	<LI>
	<STRONG><EM>Nested Transaction.</EM></STRONG> Este modelo, também conhecido como Modelo de Transações 
	Aninhadas, possibilita que uma transação possa ser formada por várias sub-transações. Em outras palavras, 
	uma única transação pode ser dividida em diversas unidades de trabalho, com cada unidade operando 
	independente uma das outras. A propriedade de atomicidade é válida para as sub-transações. Além disso, 
	uma transação não pode ser validada até que todas as suas sub-transações tenham sido finalizadas. Se 
	uma transação for interrompida, todas as suas sub-transações também serão. O contrário não é verdadeiro, 
	já que se uma sub-transação for abortada a transação que a engloba pode: ignorar o erro; desfazer a 
	sub-transação; iniciar uma outra sub-transação.
	</LI>
			
	<LI>
	<STRONG><EM>Chained Transaction. </EM></STRONG>Também conhecido como Modelo de Transações Encadeadas, esse 
	modelo tem como objetivo desfazer as operações de uma transação em caso de erro com a menor perda de 
	trabalho possível. Uma transação encadeada consiste em um conjunto de sub-transações executadas 
	seqüencialmente, em que à medida que as sub-transações vão sendo executadas, são validadas e não 
	podem mais ser desfeitas. Os resultados do conjunto de transações só serão visíveis ao final da 
	execução de todas elas.
	</LI>
			
	<LI>
	<STRONG><EM>Join Transaction.</EM></STRONG> Esse modelo permite que duas transações sejam unidas em um só, de forma que todos os recursos passam a ser compartilhados.
	</LI>
</UL>
		
<H4>Transações e Banco de Dados</H4>
		
<P>
Uma transação de banco de dados é formada por um conjunto de operações que manipulam os dados. A atomicidade de uma transação é garantida por duas operações: <EM>commit</EM> e <EM>rollback</EM>. 
</P>
		
<P>
Os limites das operações de uma transação devem ser demarcados. Assim, é possível saber 
a partir de qual operação a transação é iniciada e em qual operação ela finalizada. 
Ao final da execução da última operação que pertence à transação, todas as alterações 
no banco de dados realizadas pelas operações que compõe a transação devem 
ser confirmadas, ou seja, um <EM>commit</EM> é realizado. Se houver algum erro 
durante a execução de algumas das suas operações, todas as operações da transação 
que já foram executadas devem ser desfeitas, ou seja, um <EM>rollback</EM> é realizado. 
A Figura 1 ilustra esses conceitos.
</P>

<P align="center">
<IMG src="./JEEBrasil_O_site_da_comunidade_Java_EE_no_Brasil-5_files/img-01.gif" alt="JSP" title="JSP">
</P>

<P class="legenda">
Figura 1 - Estados do sistema durante uma transação
</P>

<H4>Ambientes Gerenciados e Não Gerenciados</H4>

<P>
As seções seguintes referem-se às definições dos conceitos relacionados a transações JDBC e JTA, onde aparecem os termos ambientes gerenciados e não gerenciados. Esta seção destina-se a explicar sucintamente o que são esses termos.
</P>

<P>
Os ambientes gerenciados são aqueles caracterizados pela gerência automática de transações realizadas por algum container. Exemplos de ambientes gerenciados são componentes EJB (<EM>Enteprise JavaBeans</EM>) executando em servidores de aplicações (<EM>JBoss</EM>, <EM>Geronimo</EM>, etc). Já os ambientes não gerenciados são cenários onde não há nenhuma gerência de transação, como por exemplo: <EM>Servlets</EM>, aplicações <EM>desktop</EM>, etc..
</P>

<H4> Transações JDBC</H4>

<P>
A tecnologia JDBC (<EM>Java Database Connectivity</EM>) é um conjunto de classes e interfaces escritas em Java, ou API, que realiza o envio de instruções SQL (<EM>Structured Query Language</EM>) para qualquer banco de dados relacional.
</P>

<P>
Uma transação JDBC é controlada pelo gerenciador de transações SGBD e geralmente é utilizada por ambientes não gerenciados. Utilizando um driver JDBC, o início de uma transação é feito implicitamente pelo mesmo.  Embora alguns bancos de dados necessitem invocar uma sentença "begin transaction" explicitamente, com a API JDBC não é preciso fazer isso. Uma transação é finalizada após a chamada do método <STRONG>commit()</STRONG>. Caso algo aconteça de errado, para desfazer o que foi feito dentro de uma transação, basta chamar o método  <STRONG>rollback(</STRONG>. Ambos,  <STRONG>commit()</STRONG> e  <STRONG>rollback()</STRONG>, são invocados a partir da conexão JDBC.
</P>

<P>
A conexão JDBC possui um atributo <STRONG>auto-commit</STRONG> que especifica quando a transação será finalizada. Se este atributo for definido como <STRONG>true</STRONG>, ou seja, se na conexão JDBC for invocado <STRONG>setAutoCommit(true)</STRONG>, ativa-se o modo de auto <EM>commit</EM>. O modo auto <EM>commit</EM> significa que para cada instrução SQL uma nova transação é criada e o <EM>commit</EM> é realizado imediatamente após a execução e finalização da mesma, não havendo a necessidade de após cada transação invocar explicitamente o método <STRONG>commit()</STRONG>.
</P>

<P>
Em alguns casos, uma transação pode envolver o armazenamento de dados em vários bancos de dados. Nessas situações, o uso apenas do JDBC pode não garantir a atomicidade. Dessa maneira, é necessário um gerenciador de transações com suporte a transações distribuídas. A comunicação com esse gerenciador de transações é feita usando JTA (<EM>Java Transaction API</EM>).
</P>

<H4>Transações JTA</H4>

<P>
As transações JTA são usadas em um ambiente gerenciável, onde existem transações CMT (<EM>Container Managed Transactions</EM>). Neste tipo de transação não há a necessidade de programação explícita das delimitações das transações, esta tarefa é realizada automaticamente pelo próprio container. Para isso, é necessário informar nos descritores dos EJBs a necessidade de suporte transacional às operações e como ele deve gerenciá-lo. 
</P>
<P>
O gerenciamento de transações é feito pelo Hibernate a partir da interface <STRONG>Transaction</STRONG>.
</P>

<H4>API para Transações do Hibernate</H4>

<P>
A interface <STRONG>Transaction</STRONG> fornece métodos para a declaração dos limites de uma transação. A Listagem 1 apresenta um exemplo de uso de transações com a interface <STRONG>Transaction</STRONG>.
</P>

<P>
A transação é iniciada a partir da invocação ao método <STRONG>session.beginTransaction()</STRONG>. No caso de um ambiente não gerenciado, uma transação JDBC na conexão JDBC é iniciada. Já no caso de um ambiente gerenciado, uma nova transação JTA é criada, caso não exista nenhuma já criada. Casa já existe uma transação JTA, essa nova transação une-se a existente.
</P>

<P>
A chamada ao método <STRONG>tx.commit()</STRONG> faz com que os dados em memória sejam sincronizados com a base de dados. O Hibernate só realiza efetivamente o <EM>commit</EM> se o comando <STRONG>beginTransaction()</STRONG> iniciar uma nova transação (em ambos ambientes gerenciado ou não gerenciado). Se o beginTransaction() não iniciar uma nova transação (no caso de transações JTA isso é possível), então o estado em sessão é apenas sincronizado com o banco de dados e a finalização da transação é feita de acordo com a primeira parte do código fonte que a criou.
</P>

<P>
Se ocorrer algum erro durante a execução do método <STRONG>acaoExecutada()</STRONG>, o método <STRONG>tx.rollback()</STRONG> é executado, desfazendo o que foi feito até o momento em que o erro ocorreu.
</P>
		
<P>
Observa-se que no final do código a sessão é finalizada a partir do comando <STRONG>session.close()</STRONG>, liberando a conexão JDBC e devolvendo-a para o pool de conexões.
</P>		


<PRE>Session session = sessions.openSession();
Transaction tx = null;
try {
	tx = session.beginTransaction();
	acaoExecutada();
	tx.commit();
} catch (Exception e) {
	if (tx != null) {
		try {
			tx.rollback();
		} catch (HibernateException he) {
			//log he and rethrow e
		}
	}
} finally {

	try {
		session.close();
	} catch (HibernateException he) {
		throw he;
	}
}
</PRE>
<P class="legenda">Listagem 1 - Usando a Interface Transaction do Hibernate</P>

<H4>Flushing</H4>

<P>
<EM>Flushing</EM> é o processo de sincronizar os dados em sessão (ou em memória) com o banco de dados. As mudanças nos objetos de domínio em memória feitas dentro do escopo de uma sessão (<STRONG>Session</STRONG>) não são imediatamente propagadas para o banco de dados. Isso permite ao Hibernate unir um conjunto de alterações e fazer um número mínimo de interações com o banco de dados, ajudando a minimizar a latência na rede.
</P>

<P>
A operação de <EM>flushing</EM> ocorre apenas em três situações: quando é dado <EM>commit</EM> na transação, algumas vezes antes de uma consulta ser executada (em situações que alterações podem influenciar em seu resultado) e quando o método <STRONG>Session.flush()</STRONG> é invocado.
</P>

<P>
O HIbernate possui um modo <EM>flush</EM> que pode ser definido a partir do comando <STRONG>session.setFlushMode()</STRONG>. Este modo pode assumir os seguintes valores:
</P>

<UL>
	<LI><STRONG>FlushMode.AUTO</STRONG>: valor padrão. Faz com que o Hibernate não realize o processo de <EM>flushing</EM> antes de todas as consultas, somente realizará se as mudanças dentro da transação alterar seu resultado.</LI>
	<LI><STRONG>FlushMode.COMMIT</STRONG>: especifica que os estados dos objetos em memória somente serão sincronizados com a base de dados ao final da transação, ou seja, quando o método <STRONG>commit()</STRONG> é chamado.</LI>
	<LI><STRONG>FlushMode.NEVER</STRONG>: especifica que a sincronização só será realizado diante da chamada explícita ao método <STRONG>flush()</STRONG>.</LI>	
</UL>

<H4>Níveis de Isolamento de uma Transação</H4>

<P>
As bases de dados tentam assegurar que uma transação ocorra de forma isolada, ou seja, mesmo que estejam acontecendo outras transações simultaneamente, é como se ela estivesse ocorrendo sozinha.
</P>

<P>
O nível de isolamento de uma transação especifica que dados estão visíveis a uma sentença dentro de uma transação. Eles impactam diretamente no nível de acesso concorrente a um mesmo alvo no banco de dados por transações diferentes.
</P>

<P>
Geralmente, o isolamento de transações é feito usando <EM>locking</EM>, que significa que uma transação pode bloquear temporariamente um dado para que outras transações não o acessem no momento que ela o está utilizando. Muitos bancos de dados implementam o nível de isolamento de uma transação através do modelo de controle concorrente multi-versões (MCC – <EM>Multiversion Concorrency Control</EM>).
</P>

<P>
Dentre alguns fenômenos que podem ocorrer devido à quebra de isolamento de uma transação estão três:
</P>

<UL>
	<LI><STRONG>Dirty Read </STRONG>(Leitura Suja): uma transação tem acesso a dados modificados por uma outra transação ainda não finalizada que ocorre concorrentemente. Isso pode causar problema, pois pode ocorrer um erro dentro da transação que está modificando os dados e as suas alterações serem desfeitas antes de confirmadas, então é possível que a transação que acessa os dados já modificados esteja trabalhando se baseando em dados incorretos.</LI>
	
	<LI><STRONG>Nonrepeatable Read </STRONG>(Leitura que não pode ser repetida): uma transação lê mais de uma vez um mesmo dado e constata que há valores distintos em cada leitura. Por exemplo, uma transação <STRONG>A</STRONG> lê uma linha do banco; uma transação <STRONG>B</STRONG> modifica essa mesma linha e é finalizada (<EM>commit</EM>) antes que a transação <STRONG>A</STRONG>; a transação <STRONG>A</STRONG> lê novamente esta linha e obtém dados diferentes. </LI>
	
	<LI><STRONG>Phantom Read</STRONG> (Leitura Fantasma): em uma mesma transação uma consulta pode ser executada mais de uma vez e retornar resultados diferentes. Isso pode ocorrer devido a uma outra transação realizar mudanças que afetem os dados consultados. Por exemplo, uma transação <STRONG>A</STRONG> lê todas as linhas que satisfazem uma condição <STRONG>WHERE</STRONG>; uma transação <STRONG>B</STRONG> insere uma nova linha que satisfaz a mesma condição antes da transação <STRONG>A</STRONG> ter sido finalizada; a transação <STRONG>A</STRONG> reavalia a condição <STRONG>WHERE</STRONG> e encontra uma linha "fantasma" na mesma consulta feita anteriormente.</LI>
	
</UL>

<P>
Existem quatro níveis de isolamento da transação em SQL. Eles se diferenciam de acordo com a ocorrência ou não dos fenômenos anteriormente descritos, como mostrado na Tabela 1.
</P>

<DIV align="center">
<TABLE cellpadding="5" cellspacing="0">
<THEAD>
	<TR>
		<TH>Nível de Isolamento</TH>
		<TH>Dirty Read</TH>
		<TH>Nonrepeatable</TH>
		<TH>Planthon Read</TH>						
	</TR>
</THEAD>
<TBODY>
	<TR>
		<TD>Read Uncommited</TD>
		<TD>SIM</TD>
		<TD>SIM</TD>
		<TD>SIM</TD>						
	</TR>	
	<TR class="cor">
		<TD>Read Commited</TD>
		<TD>NÃO</TD>
		<TD>SIM</TD>
		<TD>SIM</TD>						
	</TR>
	<TR>
		<TD>Repeatable Read</TD>
		<TD>NÃO</TD>
		<TD>NÃO</TD>
		<TD>SIM</TD>						
	</TR>
	<TR class="cor">
		<TD>Serializable</TD>
		<TD>NÃO</TD>
		<TD>NÃO</TD>
		<TD>NÃO</TD>						
	</TR>			
</TBODY>
</TABLE>
</DIV>
<P class="legenda">
Tabela 1 - Níveis de Isolamento
</P>

<P>
A escolha do nível de isolamento <EM>Read Uncommited</EM> não é recomendada para banco de dados relacionais, já que permite ler inconsistências e informações parciais (mudanças realizadas por uma transação ainda não finalizada podem ser lidas por outra transação). Se a primeira transação não for concluída, mudanças na base de dados realizadas pela segunda transação podem deixá-la com um estado inconsistente.
</P>

<P>
Com o nível <EM>Read Commited</EM>, uma transação somente visualiza mudanças feitas por outras transações quando confirmadas, permitindo que transações só acessem estados consistentes do banco. No caso de uma atualização/exclusão de uma linha de alguma tabela por uma transação, pode ser que a mesma tenha acabado de ser modificada por uma transação concorrente. Nesta situação, a transação que pretende atualizar fica esperando a transação de atualização que iniciou primeiro ser efetivada ou desfeita. Se as atualizações da primeira transação forem desfeitas, seus efeitos serão desconsiderados e a segunda transação efetivará suas mudanças considerando a linha da tabela anteriormente lida. Caso contrário, a segunda transação irá ignorar a atualização caso a linha tenha sido excluída ou aplicará a sua atualização na versão atualizada da linha.
</P>

<P>
O nível <EM>Repeatable Read</EM> não permite que uma transação sobrescreva os dados alterados por uma transação concorrente. Uma transação pode obter uma imagem completa da base de dados quando iniciada. Este nível é ideal para a geração de relatórios, pois em uma mesma transação, um registro é lido diversas vezes e seu valor se mantém o mesmo até que a própria transação altere seu valor.
</P>

<P>
Em relação ao nível <EM>Serializable</EM>, ele fornece o nível de isolamento de transação mais rigoroso. Ele permite uma execução serial das transações, como se todas as transações fossem executadas uma atrás da outra. Dessa forma, pode-se perder um pouco da performance da aplicação.
</P>

<H4>Configurando o nível de isolamento</H4>

<P>
No Hibernate cada nível de isolamento é identificado por um número:
</P>

<UL>
	<LI>1: <EM>Read Uncommited</EM></LI>
	<LI>2: <EM>Read Commited</EM></LI>
	<LI>4: <EM>Repeatable Read</EM></LI>
	<LI>8: <EM>Serializable</EM></LI>
</UL>

<P>
Para configurá-lo basta incluir a linha presente na Listagem 2 no arquivo de configuração <STRONG>*.cfg.xml</STRONG>. Neste exemplo, o nível de isolamento foi definido como <EM>Repeatable Read</EM>.
</P>



<PRE>hibernate.connection.isolation = 4
</PRE>
<P class="legenda">Listagem 2 - Configuração do Nível de Isolamento</P>

<H4> Referências</H4>

<UL>
	
<LI>Christian Bauer e Gavin King. Hibernate in Action. 2005.</LI>
<LI>Grupo Hibernate. Hibernate Reference 	Documentation. Version 3.0.5. Obtido 
     em http://www.hibernate.org</LI>
<LI>Gleydson de Azevedo Ferreira Lima. Material Didático. 2005.</LI>
<LI>Nick Heudecker. Introdução ao Hibernate.</LI>
<LI>Maurício Linhares. Introdução ao Hibernate 3.</LI>
<LI>Francesc Rosés Albiol. Introducción a Hibernate. 2003.</LI>
<LI>Fabiano Kraemer, Jerônimo Jardel Vogt. Hibernate, um Robusto Framework de 
     Persistência Objeto-Relacional. 2005.</LI>
</UL>
		</DIV>

		<A name="comentarios"></A>
		
		<DIV id="listaComentarios">
		<H4> Comentários (9) </H4>
			<DL>
				
				<DT>
				Excelente artigo, parabéns!
				</DT>
					<DD> postado por David Pereira em 17/09/2006 às 23:21</DD>
				
				<DT>
				muito massa este artigo,  estava precisando de algo assim pra meu projeto, parabens!1
				</DT>
					<DD> postado por Fernando em 07/10/2006 às 23:21</DD>
				
				<DT>
				da hora, este artigo, muito bem citado os conceitos...
				</DT>
					<DD> postado por darlan em 10/10/2006 às 23:21</DD>
				
				<DT>
				Excelente. o tópico poderia ser Transação sem Hibernate.
Parabéns!
				</DT>
					<DD> postado por João Paulo em 09/11/2006 às 23:21</DD>
				
				<DT>
				Excelente. Parabens
				</DT>
					<DD> postado por Rita Fernandes em 23/01/2007 às 23:21</DD>
				
				<DT>
				Muito bom mesmo, meu esclareceu muitas coisas.Obrigado
				</DT>
					<DD> postado por Lígia em 26/03/2007 às 23:21</DD>
				
				<DT>
				Muito bom. Parabéns
				</DT>
					<DD> postado por Warley em 30/07/2007 às 23:21</DD>
				
				<DT>
				Oláaa pessoalll....

alguem pode me explicar o que significa JEE? é voltada para que tipo de desenvolvimento?

Obrigado
Willian
				</DT>
					<DD> postado por Willia Amaral em 17/09/2007 às 23:21</DD>
				
				<DT>
				JEE significa Java Enterprise Edition.
Nada mais é do que uma plataforma para desenvolvimento Java voltado para sistemas empresariais.
				</DT>
					<DD> postado por Anderson Rodrigues Ferreira em 26/10/2008 às 23:21</DD>
				
			</DL>
		</DIV>
		

	<DIV id="comente">
	<FORM action="http://www.jspbrasil.com.br/comentario" id="form" method="post">
	<FIELDSET>
		<LEGEND>Comente!</LEGEND>
		
		

		<DIV class="notes">
      	<H4>Observações</H4>
      	<P>Os campos em <STRONG>negrito</STRONG> são <STRONG>obrigatórios</STRONG>.</P>
      	<P>Para evitar problemas, este espaço é moderado. Após o envio do comentário será
      	necessário aguardar pela sua aprovação.</P>
    	</DIV> 
		
		<DIV class="obrigatorio">
		<LABEL for="nome">Nome:</LABEL> 
		<INPUT type="text" id="nome" class="required" name="nome" size="58" value="">
		</DIV>
		
		<DIV class="optional">
		<LABEL for="email">E-Mail:</LABEL> 
		<INPUT type="text" id="email" class="validate-email" name="email" size="58" value="">
		</DIV>
		
		<DIV class="optional">
		<LABEL for="site">Site:</LABEL> 
		<INPUT type="text" id="site" class="validate-url" name="site" size="58" value="">
		</DIV>
		
		<DIV class="obrigatorio">
		<LABEL for="texto">Comentário:</LABEL> 
		<TEXTAREA name="texto" id="texto" class="required" rows="5" cols="55"></TEXTAREA>
		</DIV>
		
	    <P class="botoes">    
			<INPUT type="submit" value="Enviar">
    	</P>
		
	</FIELDSET>

	<INPUT type="hidden" name="publicacao.id" value="3">
	</FORM>
	</DIV>
	<A name="bottom">


</A></DIV><A name="bottom"> <!-- fim de content -->

<SCRIPT type="text/javascript">
	var validForm = new Validation('form');
</SCRIPT>

</A></DIV><A name="bottom"> <!-- Fim de Content -->

</A><DIV id="footer"><A name="bottom">
	</A><A href="http://www.jspbrasil.com.br/quemsomos"> Quem Somos </A> &nbsp;|&nbsp;
	<A href="mailto:sugestoes@jeebrasil.com.br"> Fale Conosco</A>
	<P>Copyright 2006 - JEEBrasil.</P>
</DIV>

</DIV> <!-- fim de page -->



</BODY></HTML>