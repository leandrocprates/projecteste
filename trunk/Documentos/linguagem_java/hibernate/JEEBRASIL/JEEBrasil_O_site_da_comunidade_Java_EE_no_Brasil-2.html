<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0038)http://www.jspbrasil.com.br/mostrar/91 -->
<HTML><STYLE>#gview-cmenu {
  position: absolute;
  border: 1px solid #ccc;
  background: #fff;
  margin: 0;
  padding: 0;
  top: 0;
  left: 0;
  z-index: 10000;
  list-style-type: none;
  -webkit-box-shadow: 0 3px 5px rgba(0, 0, 0, .5);
}

#gview-cmenu:focus {
  outline: none;
}

.gview-cmenu-item {
  margin: 0;
  padding: 5px 7px;
  cursor: default;
  font-size: 13px;
  font-family: arial, san-serif;
  color: #000;
  -webkit-user-select: none;
}

.gview-cmenu-item:hover {
  background-color: #F0F7F9;
}

.gview-cmenu-item:first-child {
  border-bottom: 1px solid #ddd;
}

.gview-hidden {
  display: none;
}
</STYLE><HEAD><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<TITLE>JEEBrasil -- O site da comunidade Java EE no Brasil</TITLE>

<SCRIPT type="text/javascript" src="./JEEBrasil_O_site_da_comunidade_Java_EE_no_Brasil-2_files/prototype.js"></SCRIPT>
<SCRIPT type="text/javascript" src="./JEEBrasil_O_site_da_comunidade_Java_EE_no_Brasil-2_files/effects.js"></SCRIPT>
<SCRIPT type="text/javascript" src="./JEEBrasil_O_site_da_comunidade_Java_EE_no_Brasil-2_files/validation.js"></SCRIPT>
<SCRIPT type="text/javascript" src="./JEEBrasil_O_site_da_comunidade_Java_EE_no_Brasil-2_files/votacao.js"></SCRIPT>
<SCRIPT type="text/javascript" src="./JEEBrasil_O_site_da_comunidade_Java_EE_no_Brasil-2_files/form.js"></SCRIPT>

<LINK href="./JEEBrasil_O_site_da_comunidade_Java_EE_no_Brasil-2_files/layout.css" rel="stylesheet" type="text/css">
<LINK href="./JEEBrasil_O_site_da_comunidade_Java_EE_no_Brasil-2_files/rating.css" rel="stylesheet" type="text/css">
<LINK href="./JEEBrasil_O_site_da_comunidade_Java_EE_no_Brasil-2_files/style.css" rel="stylesheet" type="text/css">
<LINK href="./JEEBrasil_O_site_da_comunidade_Java_EE_no_Brasil-2_files/forms.css" rel="stylesheet" type="text/css">
</HEAD><BODY>

<DIV id="page">

<!-- Cabeçalho -->
<DIV id="header">

	<DIV id="header-top">
		<H1> <A href="http://www.jspbrasil.com.br/">JEE<SPAN class="greenText">Brasil</SPAN></A> </H1>
		<H2> O site da comunidade Java EE no Brasil </H2>
	
		<DIV id="encontre">
			<H3> Encontre </H3>
			<FORM action="http://www.jspbrasil.com.br/find" method="post" id="buscaForm">
				<P>
				<INPUT id="campo" name="busca" type="text" size="26">
				<A href="http://www.jspbrasil.com.br/mostrar/91#" onclick="$(&#39;buscaForm&#39;).submit();"> Buscar </A>
				</P>
			</FORM>
		</DIV>
	</DIV>
	
	<DIV id="menu">
		<UL>
			<LI> <A href="http://www.jspbrasil.com.br/">Home</A> </LI>
			<LI> <A href="http://www.jspbrasil.com.br/noticias">Notícias</A> </LI>
			<LI> <A href="http://www.jspbrasil.com.br/eventos">Eventos</A> </LI>
			<LI> <A href="http://www.jspbrasil.com.br/artigos">Artigos</A> </LI>
			<LI> <A href="http://www.jspbrasil.com.br/tutoriais">Tutoriais</A> </LI>
			<LI> <A href="http://www.jspbrasil.com.br/tags">Tags</A> </LI>			
			<LI> <A href="http://www.jspbrasil.com.br/apresentacoes">Apresentações</A> </LI>
			<LI> <A href="http://www.jspbrasil.com.br/quemsomos">Quem Somos</A> </LI>	
			<LI id="areaRestrita"> <A href="http://www.jspbrasil.com.br/admin"><IMG src="./JEEBrasil_O_site_da_comunidade_Java_EE_no_Brasil-2_files/chave.gif" alt="Administra&ccedil;&atilde;o"></A></LI>			
		</UL>
	</DIV>
	
</DIV>

<DIV id="content">


	<DIV id="fullPanel">
		<DIV id="rightPanel">
			<H4 class="informacoes"> Informações </H4>
			<TABLE>
				<TBODY><TR>
					<TH> Tipo: </TH>
					<TD> Tutorial </TD>
				</TR>
				<TR>
					<TH> Data de Publicação: </TH>
					<TD> 07/06/2007 </TD>
				</TR>
				<TR>
					<TH> Revisado em:</TH>
					<TD> 07/06/2007 </TD>
				</TR>
			</TBODY></TABLE>
			<H4 class="nota" id="user-note">
				
				Vote!
				
				
			</H4>
			<UL class="star-rating" id="voting">
				<LI class="current-rating" id="current-rating" style="width: 109.00000000000001px">Currently 4,4/5 Stars.</LI>
				
				<LI><A href="http://www.jspbrasil.com.br/mostrar/91#" onclick="javascript:votar(91,1, &#39;&#39;);" title="muito ruim" class="one-star">1</A></LI>
				<LI><A href="http://www.jspbrasil.com.br/mostrar/91#" onclick="javascript:votar(91,2, &#39;&#39;);" title="ruim" class="two-stars">2</A></LI>
				<LI><A href="http://www.jspbrasil.com.br/mostrar/91#" onclick="javascript:votar(91,3, &#39;&#39;);" title="mais ou menos" class="three-stars">3</A></LI>
				<LI><A href="http://www.jspbrasil.com.br/mostrar/91#" onclick="javascript:votar(91,4, &#39;&#39;);" title="bom" class="four-stars">4</A></LI>
				<LI><A href="http://www.jspbrasil.com.br/mostrar/91#" onclick="javascript:votar(91,5, &#39;&#39;);" title="muito bom" class="five-stars">5</A></LI>
				
			</UL>
			
			<H4 class="tagsRelacionadas">Tags Relacionadas</H4>
			<P class="tags">
				
				<A href="http://www.jspbrasil.com.br/tags/hibernate">hibernate</A>
				
				<A href="http://www.jspbrasil.com.br/tags/persistencia">persistencia</A>
				
				<A href="http://www.jspbrasil.com.br/tags/anotacoes">anotacoes</A>
				
			</P>
			<H4 class="comentarios"><A href="http://www.jspbrasil.com.br/mostrar/91#comentarios">Comentários ( 7 )</A></H4>
			<H4 class="imprimir">Imprimir</H4>
		</DIV>

		<DIV id="tituloPublicacao">
			<H3> Mapeando Relacionamentos Entre Classes com Anotações Hibernate - Parte 1 </H3>
			<P class="autores">
				por:<BR>
				</P><P class="autor">
				
				Raphaela Galhardo Fernandes (raphaela@jeebrasil.com.br)<BR>
				
				Gleydson Lima (gleydson@jeebrasil.com.br)<BR>
				
				</P>
			<P></P>

			<P class="resumo">
			Este tutorial e o próximo destinam-se a apresentar alguns exemplos de mapeamentos de associações/relacionamentos entre classes, usando anotações Hibernate. Serão apresentados exemplos de mapeamentos dos relacionamentos 
 <EM>many-to-many</EM>, <EM>one-to-many</EM>,<EM> one-to-one</EM> ou <EM>many-to-one</EM>.

<BR><BR>
Neste tutorial serão apresentados apenas os mapeamentos dos relacionamentos  <EM>many-to-many</EM> e <EM>one-to-many</EM>.

<BR><BR>
Para baixar o tutorial no formato PDF, <A href="https://docs.google.com/viewer?url=ftp://raphaela:web@users.dca.ufrn.br/hibernate_anotacoes/T03_Relacionamentos_1.pdf">
Clique Aqui</A>

			</P>

			<H4>  </H4>
		</DIV>

		<DIV id="corpoPublicacao">
			<H4>1. Introdução </H4>


<P>
O termo associação é utilizado para se referir aos relacionamentos entre as entidades. Os relacionamentos n-para-n, n-para-1 e 1-para-n são os mais comuns entre as entidades de um banco de dados. 

</P>

<H4>
2. Associações 1-n (one-to-many)
</H4>


<P>
Para exemplificar o relacionamento 1-n, considere o relacionamento entre a entidade 
<B>Centro</B> e a entidade <B>Universidade</B> da Figura 1. O relacionamento diz que uma universidade possui um conjunto de <B>n</B> 
centros e um centro está associado a apenas uma única universidade. Considere as classes de domínio Java de uma universidade e de um centro, respectivamente, mostradas na Listagem 1 e na Listagem 2. Ambas as classes já possuem o seu mapeamento via anotações inserido.
 

</P>

<P align="center">
<IMG src="./JEEBrasil_O_site_da_comunidade_Java_EE_no_Brasil-2_files/img-03.JPG">
</P>

<P class="legenda">
Figura 1 - Relacionamento entre Centro e Universidade
</P>


<PRE>package br.com.jeebrasil.hibernate.anotacoes.dominio;
import java.util.Collection;
import javax.persistence.*;

import org.hibernate.annotations.Cascade;
import org.hibernate.annotations.CascadeType;

@Entity @Table(schema="anotacoes")
public class Universidade {

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE)
	@Column(name="id_universidade")
	private int id;
	private String nome;

	@OneToMany(mappedBy="universidade", fetch = FetchType.LAZY)
	@Cascade(CascadeType.ALL)
	private Collection<CENTRO> centros;

	//Métodos getters e setters
	//...
}
</CENTRO></PRE>

<P class="legenda">
Listagem 1 –  Classe de Domínio: Universidade
</P>


<PRE>package br.com.jeebrasil.hibernate.anotacoes.dominio;
import javax.persistence.*;

import org.hibernate.annotations.Cascade;
import org.hibernate.annotations.CascadeType;
import org.hibernate.annotations.Fetch;
import org.hibernate.annotations.FetchMode;

@Entity @Table(schema="anotacoes")
public class Centro {

	@Id @GeneratedValue(strategy = GenerationType.SEQUENCE)
	@Column(name="id_centro")
	private int id;
	private String nome;

	@ManyToOne(fetch = FetchType.EAGER)
	@JoinColumn(name="id_universidade", 
				insertable=true, updatable=true)
	@Fetch(FetchMode.JOIN)
	@Cascade(CascadeType.SAVE_UPDATE)
	private Universidade universidade;	//Métodos getters e setters
	//...
}
</PRE>

<P class="legenda">
Listagem 2 –  Classe de Domínio: Centro
</P>


<P>
As classes de domínio <B>Universidade</B> e <B>Centro</B> são mapeadas para as tabelas <B>universidade</B> e <B>centro</B>, que podem ser criadas na base de dados a 
partir dos scripts apresentados na Listagem 3 e na Listagem 4, respectivamente.
</P>


<PRE>CREATE TABLE anotacoes.universidade
(
  id_universidade integer NOT NULL, -- Identificador da tabela
  nome character(100) NOT NULL, -- Nome da universidade
  CONSTRAINT pk_universidade PRIMARY KEY (id_universidade)
) 
WITHOUT OIDS;
ALTER TABLE anotacoes.universidade OWNER TO postgres;
COMMENT ON COLUMN anotacoes.universidade.id_universidade IS 'Identificador da tabela';
COMMENT ON COLUMN anotacoes.universidade.nome IS 'Nome da universidade';

</PRE>
<P class="legenda">
Listagem 3 –  Script para a Criação da Tabela universidade
</P>



<PRE>CREATE TABLE anotacoes.centro
(
  id_centro integer NOT NULL, -- Identificador da tabela
  nome character(100) NOT NULL, -- Nome do centro
  id_universidade integer NOT NULL, 
		-- Identificador da universidade a que o centro pertence
  CONSTRAINT pk_centro PRIMARY KEY (id_centro),
  CONSTRAINT fk_centro_universidade FOREIGN KEY (id_universidade)
      REFERENCES anotacoes.universidade (id_universidade) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION
) 
WITHOUT OIDS;
ALTER TABLE anotacoes.centro OWNER TO postgres;
COMMENT ON COLUMN anotacoes.centro.id_centro IS 'Identificador da tabela';
COMMENT ON COLUMN anotacoes.centro.nome IS 'Nome do centro';
COMMENT ON COLUMN anotacoes.centro.id_universidade IS 'Identificador da universidade a que o centro pertence';

</PRE>
<P class="legenda">
Listagem 4 –  Script para a Criação da Tabela centro
</P>

<P>
A classe de domínio <B>Universidade</B> é a que possui um mapeamento do tipo 1-n através do atributo coleção de <B>centros</B>. O seu mapeamento foi feito na 
Listagem 1 a partir da anotação <B>@OneToMany</B>. Como a coleção conterá objetos do tipo <B>Centro</B>, então está classe também deverá ser uma 
classe persistente da aplicação. Na anotação <B>@OneToMany</B>, existe um atributo denominado <B>mappedBy</B> que deverá receber como valor o nome do atributo 
na classe <B>Centro</B> (classe dos tipos de objetos da coleção) que se refere à classe <B>Universidade</B> (onde há o mapeamento 1-n). Em outras palavras, a 
tabela <B>centro</B> possui uma chave estrangeira para a tabela <B>universidade</B>, representada pelo atributo <B>Universidade universidade</B> da classe<B> Centro</B>, que 
corresponderá ao atributo <B>mappedBy</B>  da anotação <B>@OneToMany</B>, ou seja, <B>mappedBy=”universidade”</B>.
</P>

<P>
Já o atributo <B>fecth</B> indica quando o conteúdo do atributo será trazido da base de dados. Pode assumir dois valores:
</P>

<UL>
<LI><B>FetchType.EAGER:</B> sempre que o objeto "pai" for trazido da base de dados, o atributo mapeado com <B>fetch=FetchType.EAGER</B> fará com que o seu conteúdo também seja trazido; </LI>
<LI><B>FetchType.LAZY:</B> sempre que o objeto "pai" for trazido da base de dados, o atributo mapeado com <B>fetch=FetchType.LAZY</B> fará com que o seu conteúdo somente seja trazido quando acessado pela primeira vez.</LI>
</UL>

<P>
A anotação <B>@Cascade</B>, também utilizada no mapeamento da coleção <B>centros</B>, serve para indicar com que ação em cascata o relacionamento será tratado, ou seja, especifica quais operações deverão ser em cascata do objeto pai para o objeto associado. Por exemplo, pode assumir alguns dos valores abaixo:
</P>

<UL>

<LI><B>CascadeType.PERSIST:</B> os objetos associados vão ser inseridos automaticamente quando o objeto "pai" for inserido;</LI>
<LI><B>CascadeType.SAVE_UPDATE:</B> os objetos associados vão ser inseridos ou atualizados automaticamente quando o objeto "pai" for inserido ou atualizado;</LI>
<LI><B>CascadeType.REMOVE:</B> os objetos associados ao objeto "pai" vão ser removidos, quando o mesmo for removido;</LI>
<LI><B>CascadeType.REPLICATE:</B> Se o objeto for replicado para outra base de dados, os filhos também serão;</LI>
<LI><B>CascadeType.LOCK:</B> Se o objeto for reassociado com a sessão persistente, os filhos também serão;</LI>
<LI><B>CascadeType.REFRESH:</B> Se o objeto for sincronizado com a base de dados, os filhos também serão;</LI>
<LI><B>CascadeType.MERGE:</B> Se um objeto tiver suas modificações mescladas em uma sessão, os filhos também terão;</LI>
<LI><B>CascadeType.EVICT:</B> Se o objeto for removido do cache de primeira nível, os filhos também serão;</LI>
<LI><B>CascadeType.ALL:</B> junção de todos os tipos de cascade.</LI>
</UL>

<P>
Para ilustrar o efeito da anotação <B>@Cascade(CascadeType.ALL)</B>, considere o exemplo da Listagem 5, onde, inicialmente, um objeto <B>Universidade</B> é criado. Em seguida, dois objetos da classe <B>Centro</B> também são criados, recebem valores para seu atributo nome e são associados ao objeto <B>universidade</B>, que é  posteriormente persistido.
</P>

<PRE>//...
	Universidade univ = new Universidade();
	univ.setNome("Universidade Federal do Rio Grande do Norte");

	Centro centro1 = new Centro();
	centro1.setNome("Centro de Tecnologia");
	centro1.setUniversidade(univ);

	Centro centro2 = new Centro();
	centro2.setNome("Centro de Humanas");
	centro2.setUniversidade(univ);

	univ.setCentros(new HashSet<CENTRO>());		univ.getCentros().add(centro1);
	univ.getCentros().add(centro2);

	session.save(univ);
//...
</CENTRO></PRE>
<P class="legenda">
Listagem 5 –  Exemplo de Persistência OneToMany. Efeito da anotação @Cascade(CascadeType.ALL)
</P>

<P>
A Listagem 6 apresenta o resultado da persistência do objeto <B>universidade</B> presente na Listagem 5. Observa-se, 
que a partir do atributo <B>cascade</B> com valor <B>CascadeType.ALL</B>, inicialmente é inserida uma linha na tabela <B>universidade</B> e 
em seguida duas linhas na tabela <B>centro</B>. Vale salientar, que na hora de inserir as linhas na tabela <B>centro</B>, como os objetos 
que as representavam foram associados ao objeto <B>universidade</B>, automaticamente, o Hibernate atribui como valor de suas chaves estrangeiras, 
o valor gerado para a chave primária da linha criada na tabela <B>universidade</B>.


</P>
Hibernate: insert into anotacoes.Universidade 
	(nome, id_universidade) values (?, ?)
Hibernate: insert into anotacoes.Centro 
	(nome, id_universidade, id_centro) values (?, ?, ?)
Hibernate: insert into anotacoes.Centro 
	(nome, id_universidade, id_centro) values (?, ?, ?)

<PRE></PRE>
<P class="legenda">
Listagem 6 – Resultado da Execução do Código da Listagem 5
</P>


<P>
O atributo centros da classe <B>Universidade</B> foi mapeado com a anotação <B>@OneToMany</B> e com o atributo <B>fecth=FetchType.EAGER</B>. A 
Listagem 7 apresenta um exemplo de consulta a uma linha na tabela <B>universidade</B> com valor de chave primária igual a 100. Na Listagem 8 
e na Listagem 9 estão os resultados da consulta considerando o atributo <B>fecth</B> da coleção definido como <B>FetchType.EAGER</B> e como <B>FetchType.LAZY</B>, 
respectivamente. 
</P>


<PRE>//...
	Session session = sf.openSession();

	//Consulta de uma linha na tabela universidade
	//com valor de chave primária = 100
	Universidade univ = 
			(Universidade)session.get(Universidade.class, 100);

	session.close();
//...

</PRE>
<P class="legenda">
Listagem 7 – Consulta para Ilustrar o Uso do Atributo fecth
</P>


<PRE>Hibernate: select universida0_.id_universidade as id1_3_1_, 
	universida0_.nome as 
	nome3_1_, centros1_.id_universidade as id3_3_, 
	centros1_.id_centro as id1_3_, centros1_.id_centro as id1_1_0_, 
	centros1_.nome as nome1_0_, 
	centros1_.id_universidade as id3_1_0_ 
from anotacoes.Universidade universida0_ 
left outer join anotacoes.Centro centros1_ on 	universida0_.id_universidade=centros1_.id_universidade
where universida0_.id_universidade=?

</PRE>
<P class="legenda">
Listagem 8 – Resultado da Execução do Código da Listagem 7 com fecth=FetchType.EAGER
</P>


<PRE>Hibernate: select universida0_.id_universidade as id1_3_0_, 
	universida0_.nome as nome3_0_ 
from anotacoes.Universidade universida0_ 
where universida0_.id_universidade=?

</PRE>
<P class="legenda">
Listagem 9 – Resultado da Execução do Código da Listagem 7 com fecth=FetchType.LAZY
</P>

<P>
A partir destes resultados, é possível observar que realmente com o valor <B>FetchType.EAGER</B>, o SQL gerado pelo Hibernate na consulta de uma universidade 
realiza um <B>left outer join</B> com a tabela centro já trazendo os dados da coleção, podendo ser desnecessário. Por outro lado, utilizando <B>FetchType.LAZY</B>, a 
consulta retorna apenas os dados referentes à <B>universidade</B>, de forma que se fossem necessários os dados da coleção, bastaria acessar o atributo que a 
representa no objeto <B>universidade</B>.
</P>

<P>
 A Listagem 10 apresenta um exemplo com a coleção <B>centros</B> mapeada com <B>FetchType.LAZY</B>. Neste exemplo, a mesma consulta à universidade de chave 
primária igual a 100 é feita e em seguida um acesso ao atributo <B>centros</B>, através da linha do código fonte <B>univ.getCentros().iterator()</B>. O resultado 
pode ser visto na Listagem 11, em que duas SQLs são geradas, uma gerada no momento da consulta à linha na tabela <B>universidade</B> de identificador igual 
a 100 e a outra no momento em que se itera a coleção <B>centros</B> do objeto anteriormente recuperado.

</P>

<PRE>//...
	Session session = sf.openSession();

	//Consulta de uma linha na tabela universidade
	//com valor de chave primária = 100.
	//fetch=FetchType.LAZY. Não traz dados da coleção centros
	Universidade univ = 
			(Universidade)session.get(Universidade.class, 100);
	//Acesso à coleção centros, de forma que os dados serão buscados
	univ.getCentros().iterator();

	session.close();
//...

</PRE>
<P class="legenda">
Listagem 10 – Consulta para Ilustrar o Uso do Atributo fecth=FetchType.LAZY
</P>

<PRE>Hibernate: select universida0_.id_universidade as id1_3_0_, 
	universida0_.nome as nome3_0_ from anotacoes.Universidade 
	universida0_ where universida0_.id_universidade=?

Hibernate: select centros0_.id_universidade as id3_1_, 
	centros0_.id_centro as id1_1_, centros0_.id_centro as id1_1_0_, 
	centros0_.nome as nome1_0_, centros0_.id_universidade as 
	id3_1_0_ from anotacoes.Centro centros0_ 
where centros0_.id_universidade=?

</PRE>
<P class="legenda">
Listagem 11 – Resultado da Execução do Código da Listagem 10
</P>

<H4>3.	Associações n-1 (many-to-one)</H4>

<P>
O relacionamento n-1 será apresentado a partir do relacionamento existente entre as classes <B>Centro</B> e <B>Universidade</B>, mostrado 
também na Figura 1. Neste caso, o relacionamento está presente no mapeamento da classe <B>Centro</B>, como mostrado na Listagem 2, a
través da anotação <B>@ManyToOne</B>. Para facilitar o entendimento, o trecho de mapeamento many-to-one do atributo <B>universidade</B> da classe 
<B>Centro</B> pode ser visto também na Listagem 12. 
</P>

<PRE>//...

@Entity @Table(schema="anotacoes")
public class Centro {
	//...

	@ManyToOne(fetch = FetchType.EAGER)
	@JoinColumn(name="id_universidade", 
				insertable=true, updatable=true)
	@Fetch(FetchMode.JOIN)
	@Cascade(CascadeType.SAVE_UPDATE)
	private Universidade universidade;	//Métodos getters e setters
	//...
}

</PRE>
<P class="legenda">
Listagem 12 - Mapeamento ManyToOne
</P>

<P>
A anotação <B>@ManyToOne</B> também possui o atributo <B>fetch</B>, que possui o mesmo comportamento apresentado anteriormente. A anotação <B>@JoinColumn</B> é utilizada 
para informar qual o nome da coluna que corresponde à chave estrangeira do mapeamento, no caso, <B>name=”id_universidade”</B>. Nesta anotação também são 
aceitáveis os atributos <B>insertable</B> e <B>updatable</B> que se assumirem <B>true</B> indica que o atributo deve ser inserido (<B>insertable</B>) ou atualizado (<B>updatable</B>) 
no momento em que o objeto que possui o relacionamento é inserido ou atualizado, respectivamente. O atributo do relacionamento não será inserido se 
<B>insertable = false</B> e não será atualizado se <B>updatable = false</B>.
</P>

<P>
Outra anotação utilizada é a <B>@Fecth</B>, que define como o atributo mapeado será recuperado da base de dados. Pode assumir três valores:
</P>

<UL>
<LI><B>FetchMode.JOIN:</B> utiliza <B>outer join</B> para carregar entidades ou coleções mapeadas;</LI>
<LI><B>FetchMode.SELECT:</B> utiliza um novo <B>select</B> para carregar entidades ou coleções mapeadas;</LI>
<LI><B>FetchMode.SUBSELECT:</B> utiliza uma consulta <B>subselect</B>  adicional para carregar coleções adicionais. Não permitido para mapeamentos <B>ManyToOne</B>.</LI>

</UL>

<P>
A Listagem 13 apresenta uma consulta à base de dados do centro com valor de chave primária igual a 110. A Listagem 14 apresenta o resultado da 
consulta com o mapeamento do atributo <B>universidade</B> da classe <B>Centro</B> utilizando a anotação <B>@Fecth</B> recebendo com valor <B>FetchMode.JOIN</B>. Pode-se observar 
que uma única consulta é feita, realizando um <B>JOIN</B> entre as tabelas <B>centro</B> e <B>universidade.</B> Já na Listagem 15, o resultado da consulta com o uso da 
anotação <B>@Fetch</B> com o valor <B>FetchMode.SELECT</B> resulta em duas consultas <B>SELECT</B> à base de dados, uma para buscar as informações do centro de 
chave primária igual a 110 e a outra para buscar as informações da universidade associada.
</P>


<PRE>//...
	Session session = sf.openSession();

	//Consulta de uma linha na tabela centro
	//com valor de chave primária = 110
	Centro centro = (Centro)session.get(Centro.class, 110);
	session.close();
//...

</PRE>
<P class="legenda">
Listagem 13 – Consulta para Ilustrar o Uso da Anotação @Fecth
</P>

<PRE>Hibernate: select centro0_.id_centro as id1_1_1_, centro0_.nome 
	as nome1_1_, centro0_.id_universidade as id3_1_1_, 
	universida1_.id_universidade as id1_3_0_, universida1_.nome as 
	nome3_0_ 
from anotacoes.Centro centro0_ 
left outer join anotacoes.Universidade 
	universida1_ on
	centro0_.id_universidade=universida1_.id_universidade 
where centro0_.id_centro=?

</PRE>
<P class="legenda">
Listagem 14 – Resultado da Execução do Código da Listagem 13 com @Fetch(FetchMode.JOIN)

</P>

<PRE>Hibernate: select centro0_.id_centro as id1_1_0_, centro0_.nome as 
	nome1_0_, centro0_.id_universidade as id3_1_0_ 
from anotacoes.Centro centro0_ where centro0_.id_centro=?

Hibernate: select universida0_.id_universidade as id1_3_0_, 
	universida0_.nome as nome3_0_ 
from anotacoes.Universidade universida0_ 
where universida0_.id_universidade=?

</PRE>
<P class="legenda">
Listagem 15 – Resultado da Execução do Código da Listagem 13 com @Fetch(FetchMode.SELECT)

</P>



<H4>4. Conclusões</H4>

<P>
Neste tutorial foram apresentados como se mapear relacionamentos entre classes do tipo muitos para um e um para muitos. Para quem já trabalhou com o mapeamento objeto relacional com Hibernate usando arquivos XML’s, percebe-se que a introdução das anotações facilitou bastante o trabalho.
</P>
<P>
No próximo tutorial, serão apresentados os mapeamentos de relacionamentos muitos para muitos e um para um.</P>
		</DIV>

		<A name="comentarios"></A>
		
		<DIV id="listaComentarios">
		<H4> Comentários (7) </H4>
			<DL>
				
				<DT>
				Poderiam colocar um fonte de uma aplicação exemplo para download.
				</DT>
					<DD> postado por Diogo A. Monteiro em 11/09/2007 às 23:21</DD>
				
				<DT>
				Tutorial bastante didático. Porém fiquei com uma dúvida:
"Nesta anotação também são aceitáveis os atributos insertable e updatable que se assumirem true indica que o atributo deve ser inserido (insertable) ou atualizado (updatable) no momento em que o objeto que possui o relacionamento é inserido ou atualizado, respectivamente. " - Isso não seria a mesma idéia da notação @Cascade(CascadeType.SAVE_UPDATE)?
				</DT>
					<DD> postado por Alan em 03/10/2007 às 23:21</DD>
				
				<DT>
				Você está falando da anotação JoinColumn? Não é a mesma idéia do cascade. Quando insertable = true, significa que o valor da chave estrangeira mapeada pelo ManyToOne e JoinColumn vai ser setada no banco de dados na tabela que tem a chave estrangeira. Com o cascade, = CascadetType.SAVE_UPDATE, se a linha na entidade não referenciada não existisse, seria criada uma linha na tabela referenciada e com insertable = true, também o valor da chave estrangeira. O mesmo com updatable, mas no contexto de atualização.
				</DT>
					<DD> postado por Raphaela em 03/10/2007 às 23:21</DD>
				
				<DT>
				Quando vão colocar o seguinte tutorial, many-to-many?
				</DT>
					<DD> postado por Raphael Domingues em 16/11/2007 às 23:21</DD>
				
				<DT>
				Gostaria de saber como seria o mapeamento se fossem schemas postgres diferentes .. 
				</DT>
					<DD> postado por Mauro em 08/05/2008 às 23:21</DD>
				
				<DT>
				Só não funciona, de resto tá bom.

Exception in thread "main" org.hibernate.AnnotationException: Use of @OneToMany or @ManyToMany targeting an unmapped class: br.com.jeebrasil.hibernate.anotacoes.dominio.Universidade.centros[br.com.jeebrasil.hibernate.anotacoes.dominio.Centro]

				</DT>
					<DD> postado por Joaquim em 29/08/2008 às 23:21</DD>
				
				<DT>
				Não funciona ou você não soube colocar para funcionar??
				</DT>
					<DD> postado por Ricardo em 24/11/2008 às 23:21</DD>
				
			</DL>
		</DIV>
		

	<DIV id="comente">
	<FORM action="http://www.jspbrasil.com.br/comentario" id="form" method="post">
	<FIELDSET>
		<LEGEND>Comente!</LEGEND>
		
		

		<DIV class="notes">
      	<H4>Observações</H4>
      	<P>Os campos em <STRONG>negrito</STRONG> são <STRONG>obrigatórios</STRONG>.</P>
      	<P>Para evitar problemas, este espaço é moderado. Após o envio do comentário será
      	necessário aguardar pela sua aprovação.</P>
    	</DIV> 
		
		<DIV class="obrigatorio">
		<LABEL for="nome">Nome:</LABEL> 
		<INPUT type="text" id="nome" class="required" name="nome" size="58" value="">
		</DIV>
		
		<DIV class="optional">
		<LABEL for="email">E-Mail:</LABEL> 
		<INPUT type="text" id="email" class="validate-email" name="email" size="58" value="">
		</DIV>
		
		<DIV class="optional">
		<LABEL for="site">Site:</LABEL> 
		<INPUT type="text" id="site" class="validate-url" name="site" size="58" value="">
		</DIV>
		
		<DIV class="obrigatorio">
		<LABEL for="texto">Comentário:</LABEL> 
		<TEXTAREA name="texto" id="texto" class="required" rows="5" cols="55"></TEXTAREA>
		</DIV>
		
	    <P class="botoes">    
			<INPUT type="submit" value="Enviar">
    	</P>
		
	</FIELDSET>

	<INPUT type="hidden" name="publicacao.id" value="91">
	</FORM>
	</DIV>
	<A name="bottom">


</A></DIV><A name="bottom"> <!-- fim de content -->

<SCRIPT type="text/javascript">
	var validForm = new Validation('form');
</SCRIPT>

</A></DIV><A name="bottom"> <!-- Fim de Content -->

</A><DIV id="footer"><A name="bottom">
	</A><A href="http://www.jspbrasil.com.br/quemsomos"> Quem Somos </A> &nbsp;|&nbsp;
	<A href="mailto:sugestoes@jeebrasil.com.br"> Fale Conosco</A>
	<P>Copyright 2006 - JEEBrasil.</P>
</DIV>

</DIV> <!-- fim de page -->



</BODY></HTML>